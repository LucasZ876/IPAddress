<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1894.3">
  <style type="text/css">
    body {background-color: #faf9f5}
    p.p2 {margin: 0.0px 0.0px 22.0px 0.0px; line-height: 21.0px; font: 16.0px 'Helvetica Neue'; color: #fcfdfa; -webkit-text-stroke: #fcfdfa}
    p.p4 {margin: 0.0px 0.0px 22.0px 0.0px; line-height: 21.0px; font: 16.0px 'Helvetica Neue'; color: #ffffff; -webkit-text-stroke: #ffffff}
    p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 21.0px; font: 16.0px 'Times New Roman'; color: #1a1a1a; -webkit-text-stroke: #1a1a1a}
    p.p7 {margin: 0.0px 0.0px 6.7px 16.0px; line-height: 21.0px; font: 16.0px Arial; color: #b40004; -webkit-text-stroke: #b40004}
    p.p8 {margin: 0.0px 0.0px 5.0px 0.0px; line-height: 21.0px; font: 16.0px Arial; color: #1a1a1a; -webkit-text-stroke: #1a1a1a}
    p.p9 {margin: 0.0px 0.0px 5.0px 48.0px; text-indent: -24.0px; line-height: 21.0px; font: 16.0px Arial; color: #1a1a1a; -webkit-text-stroke: #1a1a1a}
    p.p10 {margin: 0.0px 0.0px 5.0px 72.0px; text-indent: -24.0px; line-height: 21.0px; font: 16.0px Arial; color: #1a1a1a; -webkit-text-stroke: #1a1a1a}
    p.p11 {margin: 0.0px 0.0px 5.0px 72.0px; text-indent: -24.0px; line-height: 21.0px; font: 16.0px Times; color: #1a1a1a; -webkit-text-stroke: #1a1a1a}
    p.p12 {margin: 0.0px 0.0px 5.0px 72.0px; text-indent: -24.0px; line-height: 21.0px; font: 16.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p13 {margin: 0.0px 0.0px 5.0px 48.0px; line-height: 21.0px; font: 16.0px 'Times New Roman'; color: #1a1a1a; -webkit-text-stroke: #1a1a1a}
    p.p14 {margin: 0.0px 0.0px 5.0px 0.0px; line-height: 21.0px; font: 16.0px 'Times New Roman'; color: #1a1a1a; -webkit-text-stroke: #1a1a1a}
    p.p15 {margin: 0.0px 0.0px 5.0px 0.0px; line-height: 21.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p16 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 21.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p17 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 21.0px; font: 13.3px Times; color: #326e4c; -webkit-text-stroke: #326e4c}
    p.p18 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 21.0px; font: 16.0px Arial; color: #1a1a1a; -webkit-text-stroke: #1a1a1a}
    p.p19 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 21.0px; font: 13.3px Times; color: #6a0043; -webkit-text-stroke: #6a0043}
    p.p20 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 21.0px; font: 13.3px Times; color: #1d00ff; -webkit-text-stroke: #1d00ff}
    p.p21 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 47.3px; line-height: 21.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p22 {margin: 0.0px 0.0px 0.0px 47.3px; text-indent: 47.3px; line-height: 21.0px; font: 13.3px Times; color: #1d00ff; -webkit-text-stroke: #1d00ff}
    p.p23 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 21.0px; font: 13.3px Times; color: #562e2f; -webkit-text-stroke: #562e2f}
    p.p24 {margin: 0.0px 0.0px 0.0px 47.3px; line-height: 21.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p25 {margin: 0.0px 0.0px 5.0px 0.0px; line-height: 21.0px; font: 16.0px Arial; color: #1b1f22; -webkit-text-stroke: #1b1f22}
    p.p26 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 21.0px; font: 13.3px Times; color: #1a1a1a; -webkit-text-stroke: #1a1a1a}
    p.p27 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 47.3px; line-height: 21.0px; font: 13.3px Times; color: #1d00ff; -webkit-text-stroke: #1d00ff}
    p.p29 {margin: 0.0px 0.0px 5.0px 48.0px; text-indent: -24.0px; line-height: 21.0px; font: 16.0px Times; color: #1a1a1a; -webkit-text-stroke: #1a1a1a}
    p.p30 {margin: 0.0px 0.0px 8.0px 0.0px; line-height: 21.0px; font: 16.0px Arial; color: #1a1a1a; -webkit-text-stroke: #1a1a1a}
    p.p31 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 21.0px; font: 13.3px Times; color: #515151; -webkit-text-stroke: #515151}
    p.p32 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 21.0px; font: 13.3px Times; color: #0000b2; -webkit-text-stroke: #0000b2}
    p.p33 {margin: 0.0px 0.0px 8.0px 0.0px; line-height: 21.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p34 {margin: 0.0px 0.0px 8.0px 0.0px; line-height: 21.0px; font: 16.0px 'Times New Roman'; color: #1a1a1a; -webkit-text-stroke: #1a1a1a}
    p.p35 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 21.0px; font: 16.0px Times; color: #1a1a1a; -webkit-text-stroke: #1a1a1a}
    p.p36 {margin: 0.0px 0.0px 5.0px 48.0px; text-indent: -24.0px; line-height: 21.0px; font: 16.0px Arial; color: #000000; -webkit-text-stroke: #000000}
    p.p37 {margin: 0.0px 0.0px 5.0px 0.0px; line-height: 21.0px; font: 16.0px Times; color: #1a1a1a; -webkit-text-stroke: #1a1a1a}
    p.p38 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 47.3px; line-height: 21.0px; font: 13.3px Times; color: #562e2f; -webkit-text-stroke: #562e2f}
    p.p39 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 47.3px; line-height: 21.0px; font: 13.3px Times; color: #326e4c; -webkit-text-stroke: #326e4c}
    p.p40 {margin: 0.0px 0.0px 0.0px 47.0px; line-height: 21.0px; font: 13.3px Times; color: #562e2f; -webkit-text-stroke: #562e2f}
    p.p41 {margin: 0.0px 0.0px 0.0px 47.3px; line-height: 21.0px; font: 13.3px Times; color: #1a1a1a; -webkit-text-stroke: #1a1a1a}
    p.p43 {margin: 0.0px 0.0px 0.0px 47.3px; text-indent: 47.3px; line-height: 21.0px; font: 13.3px Times; color: #562e2f; -webkit-text-stroke: #562e2f}
    p.p44 {margin: 0.0px 0.0px 0.0px 47.3px; text-indent: 47.3px; line-height: 21.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p45 {margin: 0.0px 0.0px 0.0px 94.5px; text-indent: 47.3px; line-height: 21.0px; font: 13.3px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p46 {margin: 0.0px 0.0px 5.0px 48.0px; text-indent: -24.0px; line-height: 21.0px; font: 16.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p47 {margin: 0.0px 0.0px 5.0px 0.0px; line-height: 21.0px; font: 13.3px Times; color: #1a1a1a; -webkit-text-stroke: #1a1a1a}
    p.p48 {margin: 0.0px 0.0px 22.0px 0.0px; line-height: 21.0px; font: 14.0px 'Helvetica Neue'; color: #1a1a1a; -webkit-text-stroke: #1a1a1a; min-height: 16.0px}
    li.li3 {margin: 0.0px 0.0px 12.0px 0.0px; line-height: 14.0px; font: 14.0px 'Helvetica Neue'; color: #ffffff; -webkit-text-stroke: #ffffff}
    span.s1 {font-kerning: none; background-color: #121212}
    span.s2 {background-color: #121212; -webkit-text-stroke: 0px #000000}
    span.s3 {font-kerning: none; text-shadow: 0.0px -1.0px 0.0px rgba(153, 153, 153, 0.4)}
    span.s4 {font-kerning: none; color: #fcfdfa; background-color: #121212; -webkit-text-stroke: 0px #fcfdfa}
    span.s5 {text-decoration: underline ; font-kerning: none; color: #ffffff; -webkit-text-stroke: 0px #ffffff}
    span.s6 {font: 16.0px 'Helvetica Neue'; text-decoration: underline ; font-kerning: none}
    span.s7 {font-kerning: none}
    span.s8 {text-decoration: underline ; font-kerning: none}
    span.s9 {font: 16.0px Times; font-kerning: none}
    span.s10 {font: 9.3px 'Times New Roman'; font-kerning: none}
    span.s11 {font: 16.0px 'Lucida Grande'; font-kerning: none}
    span.s12 {font: 16.0px Arial; font-kerning: none}
    span.s13 {font: 16.0px 'Times New Roman'; font-kerning: none}
    span.s14 {font-kerning: none; color: #000000; -webkit-text-stroke: 0px #000000}
    span.s15 {font: 16.0px 'Lucida Grande'; font-kerning: none; color: #1a1a1a; -webkit-text-stroke: 0px #1a1a1a}
    span.s16 {font: 9.3px 'Times New Roman'; font-kerning: none; color: #1a1a1a; -webkit-text-stroke: 0px #1a1a1a}
    span.s17 {font: 16.0px Arial; font-kerning: none; color: #1a1a1a; -webkit-text-stroke: 0px #1a1a1a}
    span.s18 {font: 16.0px 'Times New Roman'; font-kerning: none; color: #1a1a1a; -webkit-text-stroke: 0px #1a1a1a}
    span.s19 {font-kerning: none; color: #562e2f; -webkit-text-stroke: 0px #562e2f}
    span.s20 {font-kerning: none; color: #6a0043; -webkit-text-stroke: 0px #6a0043}
    span.s21 {font-kerning: none; color: #1d00ff; -webkit-text-stroke: 0px #1d00ff}
    span.s22 {font-kerning: none; color: #0000b2; -webkit-text-stroke: 0px #0000b2}
    span.s23 {font: 13.3px Times; font-kerning: none; color: #000000; -webkit-text-stroke: 0px #000000}
    span.s24 {font-kerning: none; color: #1a1a1a; -webkit-text-stroke: 0px #1a1a1a}
    span.s25 {font-kerning: none; color: #326e4c; -webkit-text-stroke: 0px #326e4c}
    span.s26 {font: 16.0px Times; font-kerning: none; color: #000000; -webkit-text-stroke: 0px #000000}
    span.s27 {font-kerning: none; color: #515151; -webkit-text-stroke: 0px #515151}
    span.s28 {font-kerning: none; background-color: #b3b3b3}
    span.s29 {font: 16.0px Times; font-kerning: none; color: #1a1a1a; -webkit-text-stroke: 0px #1a1a1a}
    span.s30 {font: 16.0px 'Courier New'; font-kerning: none}
    span.s31 {font: 13.3px Times; font-kerning: none; color: #1d00ff; -webkit-text-stroke: 0px #1d00ff}
    span.s32 {font: 16.0px Arial; text-decoration: underline ; font-kerning: none; color: #b40004; -webkit-text-stroke: 0px #b40004}
    span.s33 {font: 16.0px 'Helvetica Neue'; font-kerning: none}
    span.s34 {font: 16.0px Times; font-kerning: none; color: #562e2f; -webkit-text-stroke: 0px #562e2f}
    span.s35 {font: 12.0px 'Helvetica Neue'; font-kerning: none}
    ul.ul1 {list-style-type: none}
  </style>
</head>
<body>
<h1 style="margin: 0.0px 0.0px 0.0px 0.0px; line-height: 39.0px; font: 30.0px 'Helvetica Light'; color: #ffffff; -webkit-text-stroke: #ffffff"><span class="s1">IPAddress</span></h1>
<p class="p2"><span class="s1">Java library for handling IP addresses and subnets, both IPv4 and IPv6</span></p>
<p class="p2"><span class="s1">Version 5.3</span></p>
<ul class="ul1">
  <li class="li3"><span class="s2"><a href="https://github.com/seancfoley/IPAddress/raw/master/IPAddress/dist/IPAddress.jar"><span class="s3">Download JAR</span></a></span></li>
  <li class="li3"><span class="s2"><a href="https://search.maven.org/artifact/com.github.seancfoley/ipaddress"><span class="s3">In Maven Central</span></a></span></li>
  <li class="li3"><span class="s2"><a href="https://github.com/seancfoley/IPAddress"><span class="s3">View On GitHub</span></a></span></li>
  <li class="li3"><span class="s2"><a href="file:///Users/scfoley/git/IPAddress/IPAddress/apidocs/"><span class="s3">Browse Javadoc</span></a></span></li>
  <li class="li3"><span class="s2"><a href="https://github.com/seancfoley/IPAddress/zipball/master"><span class="s3">ZIP repository</span></a></span></li>
  <li class="li3"><span class="s2"><a href="https://github.com/seancfoley/IPAddress/tarball/master"><span class="s3">TAR repository</span></a></span></li>
</ul>
<p class="p4"><span class="s4">See <a href="file:///Users/scfoley/git/IPAddress/v2"><span class="s5">Version 2</span></a>, <a href="file:///Users/scfoley/git/IPAddress/v3"><span class="s5">Version 3</span></a>, <a href="file:///Users/scfoley/git/IPAddress/v4"><span class="s5">Version 4</span></a></span></p>
<p class="p2"><span class="s1">This project is maintained by <a href="https://seancfoley.github.io/"><span class="s6">seancfoley</span></a></span></p>
<p class="p5"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #b40004; -webkit-text-stroke: #b40004"><span class="s7">Contents</span></h2>
<p class="p7"><span class="s8">Contents</span></p>
<p class="p7"><span class="s8">Benefits of this Library</span></p>
<p class="p7"><span class="s8">Supported IP Address Formats</span></p>
<p class="p7"><span class="s8">Core classes</span></p>
<p class="p7"><span class="s8">Parse String Representation of IP Address or Host Name</span></p>
<p class="p7"><span class="s8">IP Address and Numeric Values</span></p>
<p class="p7"><span class="s8">Networks</span></p>
<p class="p7"><span class="s8">Prefix Length Handling</span></p>
<p class="p7"><span class="s8">Address Sections</span></p>
<p class="p7"><span class="s8">IP Address Operations</span></p>
<p class="p7"><span class="s8">IP Address Ranges</span></p>
<p class="p7"><span class="s8">Parse String Representations of MAC Address</span></p>
<p class="p7"><span class="s8">MAC Address Operations</span></p>
<p class="p7"><span class="s8">IPv6 – MAC Address Integration</span></p>
<p class="p7"><span class="s8">Address Framework</span></p>
<p class="p7"><span class="s8">Conversion to String Representation of Address</span></p>
<p class="p7"><span class="s8">Searching Text of Databases for all Addresses in a Subnet</span></p>
<p class="p7"><span class="s8">Containment and Subnet Membership</span></p>
<p class="p7"><span class="s8">DNS Resolution and URLs</span></p>
<p class="p7"><span class="s8">Sorting and Comparisons</span></p>
<p class="p7"><span class="s8">Cache Classes</span></p>
<p class="p5"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #b40004; -webkit-text-stroke: #b40004"><span class="s7">Benefits of this Library</span></h2>
<p class="p8"><span class="s7">The library was intended to satisfy the following primary goals:</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7"><b>Parsing of all host name and ipv4/ipv6 address formats in common usage</b> plus some additional formats (see below or see javadoc for the </span><span class="s9">IPAddressString</span><span class="s7"> class for the extensive list)</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7"><b>Parsing and representation of subnets</b>, either those specified by network prefix length or those specified with ranges of segment values.  For example, all strings in the list below represent the same IPv4 subnet:</span></p>
<p class="p10"><span class="s11">◦</span><span class="s10">       </span><span class="s7">with CIDR network prefix length:</span><span class="s9">1.2.0.0/16</span></p>
<p class="p11"><span class="s11">◦</span><span class="s10">       </span><span class="s12">with mask: </span><span class="s7">1.2.0.0/255.255.0.0</span></p>
<p class="p10"><span class="s11">◦</span><span class="s10">       </span><span class="s7">wildcard segments: </span><span class="s9">1.2.*.*</span></p>
<p class="p10"><span class="s11">◦</span><span class="s10">       </span><span class="s7">range segments: </span><span class="s9">1.2.0-255.0-255</span></p>
<p class="p10"><span class="s11">◦</span><span class="s10">       </span><span class="s7">range using inet_aton format: </span><span class="s9">0x1.0x2.0x0-0xffff</span></p>
<p class="p10"><span class="s11">◦</span><span class="s10">       </span><span class="s7">SQL-style single wildcards to end segments: </span><span class="s9">1.2.___.___</span></p>
<p class="p10"><span class="s11">◦</span><span class="s10">       </span><span class="s7">IPv4 mapped IPv6: </span><span class="s9">::ffff:1.2.0.0/112</span></p>
<p class="p11"><span class="s11">◦</span><span class="s10">       </span><span class="s12">Hexadecimal values:</span><span class="s13"> </span><span class="s14">0x01020000-0x0102ffff</span></p>
<p class="p12"><span class="s15">◦</span><span class="s16">       </span><span class="s17">Octal values:</span><span class="s18"> </span><span class="s7">000100400000-000100577777</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7"><b>Allow the separation of address parsing from host parsing</b>.  In some cases you may have an address, in others you may have a host name, in some cases either one, so this supports all three options (for instance, when validating invalid input "1.2.3.a" as an address only, it will not be treated as a host with DNS lookup attempted in the way that </span><span class="s9">InetAddress.getByName</span><span class="s7"> does)</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7"><b>Allow control over which formats are allowed when parsing</b>, whether IPv4/6, or subnets, or inet_aton formats, and so on.</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7"><b>Produce all common address strings of different formats for a given IPv4 or IPv6 address and produce collections of such strings</b><br>
Some addresses can have hundreds of thousands of potential string representations (when you consider hex capitalization, ipv6 compression, and leading zeros, the various IPv4 and IPv6 formats, and combinations of all the above), although there are generally a handful of commonly used formats.  Generating these strings, whether the handful of commonly used strings or whether the exhaustive lists of all possible strings, can help when searching or matching addresses in databases or text.</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7"><b>Support parsing of all common MAC Address formats in usage</b></span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7"><b>Produce all common MAC address strings of different formats</b></span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7"><b>Integration of MAC Address with IPv6 with standard conversions</b></span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7"><b>Integration of IPv4 Address with IPv6 through common address conversions</b></span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7"><b>Polymorphism</b> in the code for IPv4 and IPv6 for applications which must support both transparently.  You can write generic non-version-specific code to validate addresses, connect to addresses, produce address strings, mask addresses, etc.  You can make use of the address framework which is agnostic towards address version.</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7"><b>Thread-safety and immutability</b>.  The core objects (host names, address strings, addresses, address sections, address segments) are all immutable (like </span><span class="s9">java.lang.String</span><span class="s7"> or </span><span class="s9">java.lang.Integer</span><span class="s7"> instances).  They do not change their underlying value.  For multi-threaded apps this is valuable.</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7"><b>Address modifications</b>, such as altering prefix lengths, masking, splitting into sections and segments, splitting into network and host sections, reconstituting from sections and segments</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7"><b>Address Operations</b>, such as getting the prefix block subnet for a prefixed address, iterating through subnets, iterating through prefix blocks, incrementing and decrementing addresses by integral values, reversing address bits for endianness or DNS lookup, subtracting subnets from other subnets, intersection of subnets, merging subnets, checking containment of addresses in subnets, listing subnets covering a span of addresses</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7"><b>Sorting and comparison</b> of host names, addresses, address strings and subnets</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7"><b>Integrate with the primitive java types and the standard java classes </b></span><span class="s9"><b>InetAddress</b></span><span class="s7"><b>, </b></span><span class="s9"><b>Inet6Address</b></span><span class="s7"><b>, </b></span><span class="s9"><b>Inet4Address, </b></span><span class="s7"><b>and </b></span><span class="s9"><b>BigInteger</b></span><span class="s7"><b>.</b></span></p>
<p class="p8"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #b40004; -webkit-text-stroke: #b40004"><span class="s7">Supported IP Address Formats</span></h2>
<p class="p8"><span class="s7">This includes, those supported by the well-known routines inet_aton and inet_pton, the subnet formats listed above, all combinations of the above, and others:  <span class="Apple-converted-space"> </span></span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7">all the formats supported by inet_pton and inet_aton</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7">all the formats supported by nmap</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7">all the formats produced by netstat involving hosts/addresses with ports/services</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7">the subnet formats listed above, whether prefixed, masked, wildcards, ranges</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7">IPv6 canonical, compressed (1::1), mixed (1:2:3:4:5:6:1.2.3.4), [bracketed]:port, ::1:service, and so on</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7">Hex values</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7">IPv6 base 85 values</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7">* represents all addresses both ipv4 and ipv6</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7">/x with no associated address is interpreted as the mask for prefix length x</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7">"" the empty string is considered the default loopback</span></p>
<p class="p8"><span class="s7">For a more detailed list or formats parsed, some examples are below, or see the javadoc for IPAddressString.</span></p>
<p class="p8"><span class="s7"><b> </b></span></p>
<p class="p8"><span class="s7"><b>Subnet formats</b></span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7"><b>CIDR (Classless Inter-Domain Routing) prefix length subnets<br>
</b>Adding the prefix length /x creates the address or subnet for that network prefix length, depending upon the configuration for prefix handling.  The subnet 1.2.0.0/16 is the set of all addresses starting with 1.2</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7"><b>Wildcard (* _) and range (-) subnets:</b><br>
* denotes all possible values in one or more segments, so 1.*.*.* or just 1.* is equivalent to 1.0.0.0/8<br>
0-1 denotes the range from 0 to 1 <br>
_ replaces any digit at the end of a segment, for example 1_ represents 10 to 19 in decimal or 10 to 1f in hex</span></p>
<p class="p9"><span class="s9">•</span><span class="s10">      </span><span class="s7"><b>Combinations:<br>
</b>Applying a prefix length to a subnet simply applies the prefix to every element of the subnet.  1.*.0.0/16 is the same subnet of addresses as 1.0.0.0/8</span></p>
<p class="p13"><span class="s7"> </span></p>
<p class="p8"><span class="s7">For a more detailed list or formats parsed, some examples are below, or see the javadoc for IPAddressString.</span></p>
<p class="p14"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #b40004; -webkit-text-stroke: #b40004"><span class="s7">Core classes</span></h2>
<p class="p8"><span class="s7">The core classes are </span><span class="s9"><b>HostName</b></span><span class="s7">, </span><span class="s9"><b>IPAddressString</b></span><span class="s7">,</span><span class="s9"><b> </b></span><span class="s7">and </span><span class="s9"><b>MACAddressString</b></span><span class="s7"> along with the </span><span class="s9"><b>Address</b></span><span class="s7"> base class and its subclasses </span><span class="s9"><b>IPAddress, IPv4Address</b></span><span class="s7">, </span><span class="s9"><b>IPv6Address</b></span><span class="s7">,</span><span class="s9"><b> </b></span><span class="s7">and </span><span class="s9"><b>MACAddress</b></span><span class="s7">, as well as the sequential address class </span><span class="s9"><b>IPAddressSeqRange</b></span><span class="s7"> and its subclasses </span><span class="s9"><b>IPv4AddressSeqRange</b></span><span class="s7"> and </span><span class="s9"><b>IPv6AddressSeqRange</b></span><span class="s7">.  If you have a textual representation of an IP address, then start with </span><span class="s9">HostName</span><span class="s7"> or </span><span class="s9">IPAddressString</span><span class="s7">.  If you have numeric bytes or integers, then start with </span><span class="s9">IPV4Address</span><span class="s7">, </span><span class="s9">IPV6Address</span><span class="s7"> or </span><span class="s9">MACAddress.  </span><span class="s7">Note that address instances can represent either a single address or a subnet.  If you have either an address or host name, or you have something with a port or service name, then use </span><span class="s9">HostName</span><span class="s7">.</span></p>
<p class="p14"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #b40004; -webkit-text-stroke: #b40004"><span class="s7">Parse String Representation of IP Address or Host Name</span></h2>
<p class="p8"><span class="s7">IPAddressString is used to convert.  You can use one of </span><span class="s9">getAddress</span><span class="s7"> or </span><span class="s9">toAddress</span><span class="s7">, the difference being whether parsing errors are handled by exception or not.</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p15"><span class="s7">IPAddress </span><span class="s19">address</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"1.2.3.4"</span><span class="s7">).getAddress();</span></p>
<p class="p16"><span class="s20"><b>if</b></span><span class="s7">(</span><span class="s19">address</span><span class="s7"> != </span><span class="s20"><b>null</b></span><span class="s7">) {</span></p>
<p class="p17"><span class="s14">      </span><span class="s7">//use address here</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p18"><span class="s7">or</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p16"><span class="s7">String </span><span class="s19">str</span><span class="s7"> = </span><span class="s21">"1.2.3.4"</span><span class="s7">;</span></p>
<p class="p19"><span class="s7"><b>try</b></span><span class="s14"> {</span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">address</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(str).toAddress();</span></p>
<p class="p17"><span class="s14">      </span><span class="s7">//use address here</span><span class="s14">      <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">} </span><span class="s20"><b>catch</b></span><span class="s7"> (AddressStringException </span><span class="s19">e</span><span class="s7">) {</span></p>
<p class="p17"><span class="s14">      String msg = </span><span class="s19">e</span><span class="s14">.getMessage();</span><span class="s7">//detailed message indicating issue</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p18"><span class="s7">If you have either a host name or an address, you can use HostName:</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> </span><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> main(String[] </span><span class="s19">args</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">      check(</span><span class="s20"><b>new</b></span><span class="s7"> HostName(</span><span class="s21">"[::1]"</span><span class="s7">));</span></p>
<p class="p16"><span class="s7">      check(</span><span class="s20"><b>new</b></span><span class="s7"> HostName(</span><span class="s21">"*"</span><span class="s7">));</span></p>
<p class="p16"><span class="s7">      check(</span><span class="s20"><b>new</b></span><span class="s7"> HostName(</span><span class="s21">"a.b.com"</span><span class="s7">));</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p16"><span class="s7">     <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> check(HostName </span><span class="s19">host</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>if</b></span><span class="s7">(</span><span class="s19">host</span><span class="s7">.isAddress()) {</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"address: "</span><span class="s7"> + </span><span class="s19">host</span><span class="s7">.asAddress().toCanonicalString());</span></p>
<p class="p16"><span class="s7">      } </span><span class="s20"><b>else</b></span><span class="s7"> </span><span class="s20"><b>if</b></span><span class="s7">(</span><span class="s19">host</span><span class="s7">.isAddressString()) {</span></p>
<p class="p20"><span class="s14">            System.</span><span class="s22"><b>out</b></span><span class="s14">.println(</span><span class="s7">"address string with ambiguous address: "</span><span class="s14"> +</span></p>
<p class="p16"><span class="s7">                  </span><span class="s19">host</span><span class="s7">.asAddressString());</span></p>
<p class="p16"><span class="s7">      } </span><span class="s20"><b>else</b></span><span class="s7"> {</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"host name with labels: "</span><span class="s7"> +</span></p>
<p class="p16"><span class="s7">                  Arrays.asList(</span><span class="s19">host</span><span class="s7">.getNormalizedLabels()));</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Output:</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p16"><span class="s7">address: ::1</span></p>
<p class="p16"><span class="s7">address string with ambiguous address: *</span></p>
<p class="p16"><span class="s7">host name with labels: [a, b, com]</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p18"><span class="s7"><b>Format Examples</b></span></p>
<p class="p18"><span class="s7"><b> </b></span></p>
<p class="p18"><span class="s7">Many formats are supported.  For instance, the address 1:2:3:0:0:6:: can be represented many ways as shown.</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p16"><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> parse(String </span><span class="s19">formats</span><span class="s7">[]) {</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>for</b></span><span class="s7">(String </span><span class="s19">format</span><span class="s7"> : </span><span class="s19">formats</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s19">format</span><span class="s7">).getAddress());</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p16"><span class="s7">     <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> parseHost(String </span><span class="s19">formats</span><span class="s7">[]) {</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>for</b></span><span class="s7">(String </span><span class="s19">format</span><span class="s7"> : </span><span class="s19">formats</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s20"><b>new</b></span><span class="s7"> HostName(</span><span class="s19">format</span><span class="s7">).getAddress());</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> </span><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> main(String[] </span><span class="s19">args</span><span class="s7">) {</span></p>
<p class="p21"><span class="s7">String </span><span class="s19">formats</span><span class="s7">[] = {</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"1:2:3:0:0:6::"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"1:2:3:0:0:6:0:0"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"1:2:3::6:0:0"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"0001:0002:0003:0000:0000:0006:0000:0000"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"1:2:3::6:0.0.0.0"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"1:2:3:0:0:6::"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"008JQWOV7O(=61h*;$LC"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"0x00010002000300000000000600000000"</span></p>
<p class="p16"><span class="s7">      };</span></p>
<p class="p16"><span class="s7">      parse(</span><span class="s19">formats</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      String </span><span class="s19">hostFormats</span><span class="s7">[] = {</span></p>
<p class="p22"><span class="s7">"[1:2:3:0:0:6::]"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"[1:2:3:0:0:6:0:0]"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"[1:2:3::6:0:0]"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"[0001:0002:0003:0000:0000:0006:0000:0000]"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"[1:2:3::6:0.0.0.0]"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"[1:2:3:0:0:6::]"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"[008JQWOV7O(=61h*;$LC]"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"[0x00010002000300000000000600000000]"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"0.0.0.0.0.0.0.0.6.0.0.0.0.0.0.0.0.0.0.0.3.0.0.0.2.0.0.0.1.0.0.0.ip6.arpa"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"1-2-3-0-0-6-0-0.ipv6-literal.net"</span></p>
<p class="p16"><span class="s7">      };</span></p>
<p class="p16"><span class="s7">      parseHost(</span><span class="s19">hostFormats</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Output:</span></p>
<p class="p16"><span class="s7">1:2:3::6:0:0</span></p>
<p class="p16"><span class="s7">1:2:3::6:0:0</span></p>
<p class="p16"><span class="s7">1:2:3::6:0:0</span></p>
<p class="p16"><span class="s7">1:2:3::6:0:0</span></p>
<p class="p16"><span class="s7">1:2:3::6:0:0</span></p>
<p class="p16"><span class="s7">1:2:3::6:0:0</span></p>
<p class="p16"><span class="s7">1:2:3::6:0:0</span></p>
<p class="p16"><span class="s7">1:2:3::6:0:0</span></p>
<p class="p16"><span class="s7">1:2:3::6:0:0</span></p>
<p class="p16"><span class="s7">1:2:3::6:0:0</span></p>
<p class="p16"><span class="s7">1:2:3::6:0:0</span></p>
<p class="p16"><span class="s7">1:2:3::6:0:0</span></p>
<p class="p16"><span class="s7">1:2:3::6:0:0</span></p>
<p class="p16"><span class="s7">1:2:3::6:0:0</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Subnet strings are supported as well, using CIDR prefix notation or characters indicating range (‘-‘ for a specific range or ‘*’ for full range segments).</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">For instance, the subnet </span><span class="s9">ffff::/104</span><span class="s7"> can be represented many ways:</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p16"><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> parse(String </span><span class="s19">formats</span><span class="s7">[]) {</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>for</b></span><span class="s7">(String </span><span class="s19">format</span><span class="s7"> : </span><span class="s19">formats</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s19">format</span><span class="s7">).getAddress().assignPrefixForSingleBlock());</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p16"><span class="s7">     <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> parseHost(String </span><span class="s19">formats</span><span class="s7">[]) {</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>for</b></span><span class="s7">(String </span><span class="s19">format</span><span class="s7"> : </span><span class="s19">formats</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s20"><b>new</b></span><span class="s7"> HostName(</span><span class="s19">format</span><span class="s7">).getAddress().assignPrefixForSingleBlock ());</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> </span><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> main(String[] </span><span class="s19">args</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">      String </span><span class="s19">prefixedFormats</span><span class="s7">[] = {</span></p>
<p class="p16"><span class="s7">            </span><span class="s21">"ffff::/104"</span><span class="s7">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"ffff:0:0:0:0:0:0:0/104"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"ffff:0000:0000:0000:0000:0000:0000:0000/104"</span><span class="s14">,</span></p>
<p class="p16"><span class="s7">            </span><span class="s21">"ffff::/104"</span><span class="s7">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"ffff::0.0.0.0/104"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"=q{+M|w0(OeO5^EGP660/104"</span></p>
<p class="p21"><span class="s7">};</span></p>
<p class="p16"><span class="s7">      String </span><span class="s19">rangeFormats</span><span class="s7">[] = {</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"ffff:0:0:0:0:0:0-ff:*"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"ffff::0-ff:*"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"ffff::0-ff:*"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"0xffff0000000000000000000000000000-0xffff0000000000000000000000ffffff"</span></p>
<p class="p21"><span class="s7">};</span></p>
<p class="p23"><span class="s14">      parse(</span><span class="s7">prefixedFormats</span><span class="s14">);</span></p>
<p class="p16"><span class="s7">      parse(</span><span class="s19">rangeFormats</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      String </span><span class="s19">hostFormats</span><span class="s7">[] = {</span></p>
<p class="p22"><span class="s7">"[ffff::]/104"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"[ffff:0:0:0:0:0:0:0]/104"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"[ffff:0000:0000:0000:0000:0000:0000:0000]/104"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"[ffff::]/104"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"[ffff::0.0.0.0]/104"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"[=q{+M|w0(OeO5^EGP660]/104",</span></p>
<p class="p5"><span class="s7"> </span></p>
<p class="p22"><span class="s7">"[ffff:0:0:0:0:0:0-ff:*]"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"[ffff::0-ff:*]"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"[ffff::0-ff:*]"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"[0xffff0000000000000000000000000000-0xffff0000000000000000000000ffffff]"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"*.*.*.*.*.*.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.f.f.f.f.ip6.arpa"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"ffff-0-0-0-0-0-0-0.ipv6-literal.net/104"</span></p>
<p class="p16"><span class="s7">      };</span></p>
<p class="p16"><span class="s7">      parseHost(</span><span class="s19">hostFormats</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Output:</span></p>
<p class="p16"><span class="s7">ffff::/104<span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p16"><span class="s7">ffff::/104</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7"><b>Delimited Segments</b></span></p>
<p class="p18"><span class="s7"><b> </b></span></p>
<p class="p18"><span class="s7">The subnet formats allow you to specify ranges of values.  However, if you wish to parse addresses in which values are delimited, then you can use the methods </span><span class="s9">parseDelimitedSegments(String)</span><span class="s7"> and </span><span class="s9">countDelimitedAddresses(String)</span><span class="s7"> in </span><span class="s9">IPAddressString</span><span class="s7">. The method </span><span class="s9">parseDelimitedSegments</span><span class="s7"> will provide an iterator to traverse through the individual addresses.</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">For example, given "1,2.3.4,5.6" </span><span class="s9">parseDelimitedSegments</span><span class="s7"> will iterate through "1.3.4.6", "1.3.5.6", "2.3.4.6" and "2.3.5.6".  You can then construct </span><span class="s9">IPAddressString</span><span class="s7"> instances from those individual strings for parsing.</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7"><b>Address or Host Name Validation Options</b></span></p>
<p class="p18"><span class="s7"><b> </b></span></p>
<p class="p18"><span class="s7">Validation options allow you to restrict the allowed formats, whether you wish to support just IPv4 or IPv6, or whether you wish to support just single addresses, or whether you wish to allow different variants.</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">For IP addresses, you have the class </span><span class="s9">IPAddressStringParameters</span><span class="s7"> which can be passed into </span><span class="s9">IPAddressString</span><span class="s7">, and for host names you have the class </span><span class="s9">HostNameParameters</span><span class="s7"> which can be passed into </span><span class="s9">HostName</span><span class="s7">.</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">You constrict validation options using the appropriate builder classes that are nested classes in the options classes.  Here is an example constructing host options along with nested address options within:</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p21"><span class="s7">HostNameParameters </span><span class="s22"><b>HOST_OPTIONS_EXAMPLE</b></span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> HostNameParameters.Builder().</span></p>
<p class="p16"><span class="s7">            allowEmpty(</span><span class="s20"><b>false</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">            setEmptyAsLoopback(</span><span class="s20"><b>false</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">            setNormalizeToLowercase(</span><span class="s20"><b>true</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">            allowBracketedIPv6(</span><span class="s20"><b>true</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">            allowBracketedIPv4(</span><span class="s20"><b>true</b></span><span class="s7">).getAddressOptionsBuilder().</span></p>
<p class="p16"><span class="s7">                  allowPrefix(</span><span class="s20"><b>true</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">                  allowMask(</span><span class="s20"><b>true</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">                  setRangeOptions(RangeParameters.</span><span class="s22">WILDCARD_AND_RANGE</span><span class="s7">).</span></p>
<p class="p16"><span class="s7">                  allow_inet_aton(</span><span class="s20"><b>true</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">                  allowEmpty(</span><span class="s20"><b>false</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">                  setEmptyAsLoopback(</span><span class="s20"><b>false</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">                  allowAll(</span><span class="s20"><b>false</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">                  allowPrefixOnly(</span><span class="s20"><b>false</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">                  getIPv4AddressParametersBuilder().</span></p>
<p class="p16"><span class="s7">                        allowPrefixLengthLeadingZeros(</span><span class="s20"><b>true</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">                        allowPrefixesBeyondAddressSize(</span><span class="s20"><b>false</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">                        allowWildcardedSeparator(</span><span class="s20"><b>true</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">                        getParentBuilder().getParentBuilder().toParams();</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">The default options used by the library are permissive and not restrictive.</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><b>Host Name or Address with Port or Service Name</b></span></p>
<p class="p8"><span class="s7">For an address or host with port or service name, use </span><span class="s9">HostName</span><span class="s7">.  IPv6 addresses with ports should appear as [ipv6Address]:port to resolve the ambiguity of the colon separator, consistent with RFC 2732, 3986, 4038 and other RFCs.  However, this library will parse IPv6 addresses without the brackets.  You can use the “expectPort” setting of HostNameParameters to resolve ambiguities when the brackets are absent.</span></p>
<p class="p21"><span class="s7">HostName </span><span class="s19">hostName</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> HostName(</span><span class="s21">"[::1]:80"</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"host: "</span><span class="s7"> + </span><span class="s19">hostName</span><span class="s7">.getHost() + </span><span class="s21">" address: "</span><span class="s7"> + </span><span class="s19">hostName</span><span class="s7">.getAddress() + </span><span class="s21">" port: "</span><span class="s7"> + </span><span class="s19">hostName</span><span class="s7">.getPort());</span></p>
<p class="p16"><span class="s7">      </span><span class="s19">hostName</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> HostName(</span><span class="s21">"localhost:80"</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"host: "</span><span class="s7"> + </span><span class="s19">hostName</span><span class="s7">.getHost() + </span><span class="s21">" port: "</span><span class="s7"> + </span><span class="s19">hostName</span><span class="s7">.getPort());</span></p>
<p class="p24"><span class="s19">hostName</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> HostName(</span><span class="s21">"127.0.0.1:80"</span><span class="s7">);<br>
System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"host: "</span><span class="s7"> + </span><span class="s19">hostName</span><span class="s7">.getHost() + </span><span class="s21">" address: "</span><span class="s7"> + </span><span class="s19">hostName</span><span class="s7">.getAddress() + </span><span class="s21">" port: "</span><span class="s7"> + </span><span class="s19">hostName</span><span class="s7">.getPort());</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7">Output:</span></p>
<p class="p16"><span class="s7">host: ::1 address: ::1 port: 80</span></p>
<p class="p16"><span class="s7">host: localhost port: 80<br>
host: 127.0.0.1 address: 127.0.0.1 port: 80</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><b>IP Version Determination and IPv4/v6 Conversion</b></span></p>
<p class="p8"><span class="s7">With an </span><span class="s9">IPAddress</span><span class="s7"> or </span><span class="s9">IPAddressString</span><span class="s7"> object, you can check the version with </span><span class="s9">isIPv4()</span><span class="s7"> and </span><span class="s9">isIPv6()</span><span class="s7"> and get the appropriate subclass with </span><span class="s9">toIPv4()</span><span class="s7"> or </span><span class="s9">toIPv6()</span><span class="s7">.  You can also make use of </span><span class="s9">isIPv4Convertible()</span><span class="s7"> and </span><span class="s9">isIPv6Convertible()</span><span class="s7"> to do further conversions if the address is IPv4 mapped, or you can use your own instance of </span><span class="s9">IPAddressConverter</span><span class="s7"> for some other suitable conversion (IPv4 translated, 6to4, 6over4, IPv4 compatible, or other).</span></p>
<p class="p15"><span class="s7">IPAddressString </span><span class="s19">str</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"::ffff:1.2.3.4"</span><span class="s7">);</span></p>
<p class="p16"><span class="s20"><b>if</b></span><span class="s7">(</span><span class="s19">str</span><span class="s7">.isIPv6()) {</span></p>
<p class="p16"><span class="s7">      IPv6Address </span><span class="s19">ipv6Address</span><span class="s7"> = </span><span class="s19">str</span><span class="s7">.getAddress().toIPv6();</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">ipv6Address</span><span class="s7">.toMixedString());</span></p>
<p class="p16"><span class="s7"><b>      </b></span><span class="s20"><b>if</b></span><span class="s7">(</span><span class="s19">ipv6Address</span><span class="s7">.isIPv4Convertible()) {</span></p>
<p class="p16"><span class="s7">            IPv4Address </span><span class="s19">ipv4Address</span><span class="s7"> = </span><span class="s19">ipv6Address</span><span class="s7">.toIPv4();</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">ipv4Address</span><span class="s7">.toNormalizedString());</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p18"><span class="s23">}</span><span class="s7"><br>
<br>
</span></p>
<p class="p18"><span class="s7">Output:</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p16"><span class="s7">::ffff:1.2.3.4</span></p>
<p class="p16"><span class="s7">1.2.3.4</span></p>
<p class="p14"><span class="s7"> </span></p>
<p class="p8"><span class="s7">Should you wish to change the default IPv4/IPv6 conversions from IPv4 mapped to something else, you can override the pair of methods </span><span class="s9">toIPv4()</span><span class="s7"> and </span><span class="s9">isIPv4Convertible()</span><span class="s7"> in your own </span><span class="s9">IPv6Address</span><span class="s7"> subclass and/or the pair of methods </span><span class="s9">toIPv6()</span><span class="s7"> and </span><span class="s9">isIPv6Convertible()</span><span class="s7"> in your own </span><span class="s9">IPv4Address</span><span class="s7"> subclass.</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><b>Prefixed Addresses and toHostAddress()</b></span></p>
<p class="p8"><span class="s7">This library will parse CIDR prefix IP addresses such as 10.1.2.3/24. Network addresses like 10.1.2.0/24 and a:b:c:d::/64 are parsed as the prefix block of addresses for the indicated prefix length (alternative options for parsing prefix lengths are described in the section on prefix length handling).</span></p>
<p class="p25"><span class="s7">If you have an individual address or a subnet with prefix length and you want to get the address instance representing the entire block for that prefix, you can call </span><span class="s9">toPrefixBlock()</span><span class="s7">.  In the reverse direction, given an entire block for a prefix, you can get the IPv4 network address or the IPv6 anycast address by calling </span><span class="s9">getLower()</span><span class="s7">.</span></p>
<p class="p25"><span class="s7">When parsing, you can always obtain the individual address without the prefix length attached.  For that there are the methods </span><span class="s9">getHostAddress()</span><span class="s7"> or </span><span class="s9">toHostAddress()</span><span class="s7"> which will provide the original host address 10.1.2.3 when parsing 10.1.2.3/24.  You can also get the prefix length by calling </span><span class="s9">getNetworkPrefixLength()</span><span class="s7"> on the </span><span class="s9">IPAddressString</span><span class="s7"> or </span><span class="s9">IPAddress </span><span class="s7">instance.</span></p>
<p class="p25"><span class="s7">The example code below shows some of these methods and the default prefix length handling behavior.</span></p>
<p class="p21"><span class="s7"> </span></p>
<p class="p16"><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> printPrefixedAddresses(String addressStr) {</span></p>
<p class="p16"><span class="s7">      IPAddressString </span><span class="s19">ipAddressString</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(addressStr);</span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">address</span><span class="s7"> = </span><span class="s19">ipAddressString</span><span class="s7">.getAddress();</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"count: "</span><span class="s7"> + </span><span class="s19">address</span><span class="s7">.getCount());</span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">hostAddress</span><span class="s7"> = </span><span class="s19">ipAddressString</span><span class="s7">.getHostAddress();</span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">prefixBlock</span><span class="s7"> = </span><span class="s19">address</span><span class="s7">.toPrefixBlock();</span></p>
<p class="p24"><span class="s7">Integer </span><span class="s19">prefixLength</span><span class="s7"> = </span><span class="s19">ipAddressString</span><span class="s7">.getNetworkPrefixLength();</span><span class="s18"><br>
</span><span class="s7">System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toCanonicalWildcardString());</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">hostAddress</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">prefixLength</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">prefixBlock</span><span class="s7">);</span><span class="s24"><span class="Apple-converted-space"> </span></span></p>
<p class="p21"><span class="s7">System.</span><span class="s22"><b>out</b></span><span class="s7">.println();</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">printPrefixedAddresses(</span><span class="s21">"10.1.2.3/24"</span><span class="s7">);</span><span class="s25">//individual address</span></p>
<p class="p16"><span class="s7">printPrefixedAddresses(</span><span class="s21">"10.1.2.0/24"</span><span class="s7">);</span><span class="s25">//network</span></p>
<p class="p16"><span class="s7">     <span class="Apple-converted-space"> </span></span></p>
<p class="p18"><span class="s7">Output:</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p16"><span class="s7">count: 1</span></p>
<p class="p16"><span class="s7">10.1.2.3/24</span></p>
<p class="p16"><span class="s7">10.1.2.3</span></p>
<p class="p16"><span class="s7">10.1.2.3</span></p>
<p class="p16"><span class="s7">24</span></p>
<p class="p16"><span class="s7">10.1.2.0/24</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">count: 256</span></p>
<p class="p16"><span class="s7">10.1.2.0/24</span></p>
<p class="p16"><span class="s7">10.1.2.*</span></p>
<p class="p16"><span class="s7">10.1.2.0</span></p>
<p class="p16"><span class="s7">24</span></p>
<p class="p16"><span class="s7">10.1.2.0/24</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><b>Parse Non-Segmented Addresses – Hex, Octal, IPv6 Base 85</b></span></p>
<p class="p8"><span class="s7">Typically, the segments or other punctuation identify a string as a host name, as an IPv4 address, or as an IPv6 address.  The parser will also parse single segment values or a range of single segment values. <span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s7">With non-segmented addresses, ambiguity between IPv4 and IPv6 is resolved by the number of digits in the string.  The number of digits is 32 for IPv6 hexadecimal, 20 for IPv6 base 85 (see RFC 1924), and 11 or less for IPv4, which can be octal, hexadecimal, or decimal.  For IPv4, digits are presumed decimal unless preceded by 0x for hexadecimal or 0 for octal, as is consistent with the inet_aton routine.  For IPv6, 32 digits are considered hexadecimal and the preceding 0x is optional.</span></p>
<p class="p21"><span class="s7">IPAddressString </span><span class="s19">ipAddressString</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"4)+k&amp;C#VzJ4br&gt;0wv%Yp"</span><span class="s7">);</span><span class="s25">//base 85</span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">address</span><span class="s7"> = </span><span class="s19">ipAddressString</span><span class="s7">.getAddress();</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p20"><span class="s14">      </span><span class="s19">ipAddressString</span><span class="s14"> = </span><span class="s20"><b>new</b></span><span class="s14"> IPAddressString(</span><span class="s7">"108000000000000000080800200c417a"</span><span class="s14">);</span><span class="s25">//hex IPv6</span></p>
<p class="p16"><span class="s7">      </span><span class="s19">address</span><span class="s7"> = </span><span class="s19">ipAddressString</span><span class="s7">.getAddress();</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">      </span><span class="s19">ipAddressString</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"0x01020304"</span><span class="s7">);</span><span class="s25">//hex IPv4</span></p>
<p class="p16"><span class="s7">      </span><span class="s19">address</span><span class="s7"> = </span><span class="s19">ipAddressString</span><span class="s7">.getAddress();</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">      </span><span class="s19">ipAddressString</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"000100401404"</span><span class="s7">);</span><span class="s25">//octal IPv4</span></p>
<p class="p16"><span class="s7">      </span><span class="s19">address</span><span class="s7"> = </span><span class="s19">ipAddressString</span><span class="s7">.getAddress();</span></p>
<p class="p24"><span class="s7">System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">);</span></p>
<p class="p24"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Output:</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p16"><span class="s7">1080::8:800:200c:417a</span></p>
<p class="p16"><span class="s7">1080::8:800:200c:417a</span></p>
<p class="p16"><span class="s7">1.2.3.4<br>
1.2.3.4</span></p>
<p class="p15"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><b>Parse Special Host Names – Reverse DNS Host Name, IPv6 Literal UNC Host Name</b></span></p>
<p class="p8"><span class="s7">A couple of standardized host formats are recognized, namely the reverse DNS host format, and the UNC IPv6 literal host format.</span></p>
<p class="p27"><span class="s14">HostName </span><span class="s19">hostName</span><span class="s14"> = </span><span class="s20"><b>new</b></span><span class="s14"> HostName(</span><span class="s7">"a.7.1.4.c.0.0.2.0.0.8.0.8.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.0.1.ip6.arpa"</span><span class="s14">);</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">hostName</span><span class="s7">.asAddress());</span></p>
<p class="p20"><span class="s14">      </span><span class="s19">hostName</span><span class="s14"> = </span><span class="s20"><b>new</b></span><span class="s14"> HostName(</span><span class="s7">"4.3.2.1.in-addr.arpa"</span><span class="s14">);</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">hostName</span><span class="s7">.asAddress());</span></p>
<p class="p24"><span class="s19">hostName</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> HostName(</span><span class="s21">"1080-0-0-0-8-800-200c-417a.ipv6-literal.net"</span><span class="s7">);<br>
System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">hostName</span><span class="s7">.asAddress());<br>
<br>
</span></p>
<p class="p18"><span class="s7">Output:</span></p>
<p class="p16"><span class="s7">1080::8:800:200c:417a</span></p>
<p class="p16"><span class="s7">1.2.3.4<br>
1080::8:800:200c:417a</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p18"><span class="s7">A couple of methods in </span><span class="s9">HostName</span><span class="s7"> are available as well:</span></p>
<p class="p5"><span class="s7"> </span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> </span><span class="s20"><b>boolean</b></span><span class="s7"> isUNCIPv6Literal()<br>
</span><span class="s20"><b>public</b></span><span class="s7"> </span><span class="s20"><b>boolean</b></span><span class="s7"> isReverseDNS()</span></p>
<p class="p19"><span class="s7"><b> </b></span></p>
<p class="p19"><span class="s7"><b> </b></span></p>
<p class="p18"><span class="s7"><b>Parse IPv6 Zone or Scope ID<br>
<br>
</b></span></p>
<p class="p18"><span class="s7">The IPv6 zone or scope ID is recognized, denoted by the ‘%’ character.  It can be retrieved by </span><span class="s9">IPv6Address.getZone()</span><span class="s7">.</span></p>
<p class="p21"><span class="s7">IPAddress </span><span class="s19">addr</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"::%eth0"</span><span class="s7">).getAddress();</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>if</b></span><span class="s7">(</span><span class="s19">addr</span><span class="s7">.isIPv6()) {</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">addr</span><span class="s7">.toIPv6().getZone());</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Output:</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p16"><span class="s7">eth0</span></p>
<p class="p14"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #1a1a1a; -webkit-text-stroke: #1a1a1a"><span class="s7">IP Address and Numeric Values</span></h2>
<p class="p18"><span class="s7">In addition to the range of string formats that can be parsed to produce </span><span class="s9">IPAddress</span><span class="s7"> instances, you can also obtain instances of </span><span class="s9">IPAddress</span><span class="s7"> from byte arrays, </span><span class="s9">java.net.InetAddress</span><span class="s7">, arrays of address segments, or individual integer segment values.</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">For IPv4 you have the additional option of constructing an address from a 32-bit integer.  For IPv6, you have the additional options of constructing from a </span><span class="s9">java.lang.BigInteger</span><span class="s7"> and constructing from MAC addresses.</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Once you have an </span><span class="s9">IPAddress</span><span class="s7"> instance, there are methods to convert to bytes, to a </span><span class="s9">java.lang.BigInteger</span><span class="s7">, to sections, to subnets or network prefixes, to masks, to </span><span class="s9">java.net.InetAddress</span><span class="s7">, to different string representations, and so on.</span></p>
<p class="p19"><span class="s7"><b> </b></span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #1a1a1a; -webkit-text-stroke: #1a1a1a"><span class="s7">Networks</span></h2>
<p class="p8"><span class="s7">Each of the different address types (IPv6, IPv4, MAC) has an associated singleton network object.  The network objects are used for caching, for configuration, and have methods for obtaining masks and loopbacks.  Each of the network objects have singleton creator objects that are used to create addresses, sections, and segments, and those creator objects perform caching of these address components for efficient memory usage and performance.  All internally created address components and addresses are created by the creator object, whether by the string parsing engine or by address object manipulation.</span></p>
<p class="p8"><span class="s7">The </span><span class="s26">defaultIpv6Network()</span><span class="s7">,</span><span class="s26"> defaultIpv4Network()</span><span class="s7">,</span><span class="s23"> </span><span class="s7">and </span><span class="s26">defaultMACNetwork() </span><span class="s7">methods in </span><span class="s9">Address</span><span class="s7">  provide access to the respective network objects.  Each network’s associated creator object is accessible from </span><span class="s9">getAddressCreator()</span><span class="s7">.</span></p>
<p class="p14"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><b>Using your own address classes</b></span></p>
<p class="p8"><span class="s7">Users can create their own subclasses of the address and address component classes (eg your own subclasses of </span><span class="s9">IPv6Address</span><span class="s7">, </span><span class="s9">IPv6AddressSection</span><span class="s7"> and/or </span><span class="s9">IPv6AddressSegment</span><span class="s7">).</span></p>
<p class="p8"><span class="s7">When doing so, you may wish to use your own network classes as well. To do so, you</span></p>
<p class="p29"><span class="s11">·</span><span class="s10">      </span><span class="s12">override </span><span class="s7">getNetwork()</span></p>
<p class="p9"><span class="s11">·</span><span class="s10">      </span><span class="s7">override </span><span class="s9">getIPv6Network()</span><span class="s7">, </span><span class="s9">getIPv4Network()</span><span class="s7">, and </span><span class="s9">getMACNetwork()</span><span class="s7">, if any of those methods exist in the class you are subclassing.  Several of those methods may exist in the same class because address components sometimes create components of other address versions or types (eg embedding IPv4 in IPv6, or MAC integration with IPv6).</span></p>
<p class="p8"><span class="s7">Once you have done so, your new address classes are using your own network classes as well.</span></p>
<p class="p8"><span class="s7">When using your own network classes, you can override the method </span><span class="s9">createAddressCreator() </span><span class="s7">or the method</span><span class="s9"> getAddressCreator() </span><span class="s7">in </span><span class="s9">AddressNetwork</span><span class="s7">, and in so doing provide your own creator objects, in which you can override any or all of the creation methods to use your own classes.</span></p>
<p class="p8"><span class="s7">You can make the string parsing engine use your own address or network classes.  To do this, your code should create your own string validation objects using the builder classes </span><span class="s26">MACAddressStringParameters.Builder</span><span class="s7">, </span><span class="s26">IPAddressStringParameters.Builder</span><span class="s7"> and </span><span class="s9">HostNameParameters.Builder</span><span class="s7">.  With </span><span class="s9">HostNameParameters.Builder</span><span class="s7"> you must get the </span><span class="s26">IPAddressStringParameters.Builder</span><span class="s7"> sub-builder by calling </span><span class="s26">getAddressOptionsBuilder()</span><span class="s7">.  With </span><span class="s26">IPAddressStringParameters.Builder</span><span class="s7"> you must get the IPv4 or IPv6 sub-builder by calling one of </span><span class="s26">getIPv6Parameters()</span><span class="s23"> </span><span class="s7">or </span><span class="s26">getIPv4Parameters()</span><span class="s7">.  You then call </span><span class="s26">setNetwork()</span><span class="s23"> </span><span class="s7">on the builder or sub-builder objects to supply your own network. The initial builder can create your own validation objects with </span><span class="s9">toParams()</span><span class="s7">.  Those validation objects can be supplied to the appropriate constructor of </span><span class="s9">IPAddressString</span><span class="s7"> or </span><span class="s9">MACAddressString</span><span class="s7">, and the subsequent string parsing with those instances will use the supplied networks.</span></p>
<p class="p8"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #1a1a1a; -webkit-text-stroke: #1a1a1a"><span class="s7">Prefix Length Handling</span></h2>
<p class="p8"><span class="s7">Prefix lengths are supported both in parsing, as indicated in the section above on parsing, as well as when directly constructing addresses or sections.  Addresses and sections store their prefix lengths and the prefix is incorporated in numerous address operations as well as when producing strings.  For instance, an address will provide the network section upon calls to </span><span class="s9">getNetworkSection()</span><span class="s7"> in </span><span class="s9">IPAddress</span><span class="s7">, and will supply the prefix length when calling </span><span class="s9">getNetworkPrefixLength().</span></p>
<p class="p8"><span class="s7">Given an address with no prefix length, you can convert to an address with prefix length using the methods </span><span class="s9">assignPrefixForSingleBlock()</span><span class="s7"> or </span><span class="s9">assignMinPrefixForBlock()</span><span class="s7"> in </span><span class="s9">IPAddress</span><span class="s7">, or any of the methods that allow you to set any given prefix length directly such as </span><span class="s9">setPrefixLength(int)</span><span class="s7">.</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><b>Prefix Length and Equality</b></span></p>
<p class="p8"><span class="s7">In this library, the subnet with prefix length 10.1.2.*/24 is equivalent the non-prefixed address 10.1.2.* as they both contain the same set of addresses.   When it comes to equality or comparison, the prefix length has no effect. <span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><b>Alternative Options for Prefix Length Handling<span class="Apple-converted-space"> </span></b></span></p>
<p class="p8"><span class="s7">As indicated in the section on parsing, when constructing an IP address with prefix length, you can end up with an individual address or a subnet if you provide a network address.  This is also true for address and address sections constructed from numeric values rather than strings.  When you specify the network address of a subnet with its corresponding prefix length, then the resulting object will be the subnet, and not an individual address.</span></p>
<p class="p8"><span class="s7">In version 3 and earlier, prefixed addresses and sections were always converted to the subnet block of addresses for that prefix, regardless of whether you specified the network address or any other address.</span></p>
<p class="p8"><span class="s7">In the current version, there are three options available, the version 3 legacy behavior, the new default behavior, and a third option:</span></p>
<p class="p9"><span class="s13">1.</span><span class="s10">     </span><span class="s26"><b>ALL_PREFIXED_ADDRESSES_ARE_SUBNETS</b></span><span class="s7">: An address with a prefix length is always the subnet block for that prefix.  This is the legacy behavior, the behaviour for versions 3 and under of this library.  An address like 1.2.3.4/16 is equivalent to 1.2.*.*/16, and a:b:c:d::/64 is equivalent to a:b:c:d:*:*:*:*/64<br>
<br>
</span></p>
<p class="p9"><span class="s13">2.</span><span class="s10">     </span><span class="s9"><b>PREFIXED_ZERO_HOSTS_ARE_SUBNETS</b>: </span><span class="s7">An address with a prefix length and a zero-valued host is the subnet block for that prefix.  An address with a host value of non-zero is a single address corresponding to a single host.  This is the new default behavior for this library since it is a convention with common usage.  <br>
<br>
For example, the IPv4 address 1.2.3.4/16 is just a single address and not a subnet, while 1.2.0.0/16 is the prefix block, it is the subnet 1.2.*.*/16.  </span><span class="s13"><br>
<br>
</span><span class="s7">This behavior is akin to the common convention used by many network administrators, many routers and many applications.  With IPv4, an address with a host value of zero is known as the network address.  It often represents the subnet of all addresses with that same prefix.  It is often used for routing.  The all-zero address 0.0.0.0 is conventionally known as INADDR_ANY (any address on the local machine), it is the address that returns true for java.net.Inet4Address.isAnyLocalAddress(), and when paired with prefix zero it is known as the default route (the route for all addresses).</span><span class="s13"><br>
<br>
</span><span class="s7">With IPv6, the convention is similar and this option results in the same behaviour.  It is a standard convention with IPv6 to denote a subnet like 1:2:3:4::/64, with a zero-valued (and usually compressed) host, and that subnet represents the prefix block all addresses starting with that prefix 1:2:3:4.  An address with a host of zero is known as the anycast address.  The all-zero address '::' is the value of IN6ADDR_ANY_INIT, the analog to the IPv4 INADDR_ANY), and the address that returns true for java.net.Inet6Address.isAnyLocalAddress().<br>
<br>
</span></p>
<p class="p9"><span class="s13">3.</span><span class="s10">     </span><span class="s9"><b>EXPLICIT_SUBNETS</b></span><span class="s7">: The third option is the one in which a subnet block derived from a prefix length must be explicitly defined, you must list the range of values explicitly.  Any subnet must be explicitly defined, like 1.2.*.*/16, while 1.2.0.0/16 is just a single address.<br>
<br>
</span></p>
<p class="p8"><span class="s7">Version 3 and earlier versions of the library provided only the first behavior.  All three options are available starting with version 4 of this library, while the default behavior is the second options listed and is most consistent with common conventions used widely for IP addresses.</span></p>
<p class="p8"><span class="s7">The options above are generally geared towards IP addresses.  With MAC Addresses prefix lengths are implicit for the most part (and cannot be specified as part of an address string explicitly).  MAC address prefix lengths are discussed in more detail in the section below “MAC Address Prefix Lengths”   With MAC there is no difference between options 2 and 3 since there is no analog to the zero-host/network/anycast address.  With MAC, when using an operation that allows you to supply a prefix, the first option above results in addresses that span all values beyond the prefix, while options 2 and 3 do not.</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><b>Configuring Alternative Prefix Length Handling</b></span></p>
<p class="p30"><span class="s7">To choose one of the non-default prefix length handling options, such as the legacy option, you make use of the </span><span class="s9">PrefixConfiguration</span><span class="s7"> enum type and the network objects.</span></p>
<p class="p30"><span class="s7">Each address version/type (IPv4, IPv6, MAC) has an associated network object and each network object has a </span><span class="s9">PrefixConfiguration</span><span class="s7"> setting.  Prefix length has a similar meaning for MAC but with some key differences outlined below. By default, all networks use the same setting of </span><span class="s9">PREFIXED_ZERO_HOSTS_ARE_SUBNETS</span><span class="s7"> stored in a single static field in the </span><span class="s9">AddressNetwork</span><span class="s7"> class.</span></p>
<p class="p30"><span class="s7">By calling </span><span class="s26">setPrefixConfiguration</span><span class="s23"> </span><span class="s7">in </span><span class="s26">AddressNetwork</span><span class="s7"> and you can change this default setting for all networks.  Or, you can call </span><span class="s26">setPrefixConfiguration </span><span class="s7">in one or more of </span><span class="s9">IPv4AddressNetwork</span><span class="s7">, </span><span class="s9">IPv6AddressNetwork</span><span class="s7">, or </span><span class="s9">MACAddressNetwork</span><span class="s7">, to set each one individually.</span><span class="s23">  </span><span class="s7">Typically, you would change the setting when the application starts.  Should you choose to do so at a different point in the application lifetime, it should be noted that the behavior is undefined when using pre-existing address objects following such a change.  It is recommended that the prefix length configuration remain constant throughout the lifetime of an application, or that existing address objects be discarded when the configuration is changed.</span></p>
<p class="p30"><span class="s7">If discarding existing address objects, keep in mind that the library caches address and address component objects.  To discard those cached objects you can clear those caches by calling </span><span class="s26">defaultIpv6Network()</span><span class="s7">,</span><span class="s26"> defaultIpv4Network()</span><span class="s7">,</span><span class="s23"> </span><span class="s7">and </span><span class="s26">defaultMACNetwork()</span><span class="s7"> to get the default network objects and then call </span><span class="s9">clearCaches()</span><span class="s7"> on each one. <span class="Apple-converted-space"> </span></span></p>
<p class="p30"><span class="s7">If two applications using the IPAddress library at the same time in the same process require conflicting prefix configurations, then one option to achieve this is to use different class loaders in the separate apps, loading the IPAddress library in separate class loaders.  In fact, many popular java applications already use class loaders for code separation, such as the Eclipse framework which uses them to separate plugins and the Apache Tomcat web server which uses them to separate webapps. <span class="Apple-converted-space"> </span></span></p>
<p class="p30"><span class="s7">If you cannot load the library in separate class loaders, then another option is available to you.  This option is to use your own network classes.  The procedure for using your own network classes is described above in the section of this document on networks.  The first step us to subclass the address and address component classes.  The next step is to override the key methods for accessing the networks in those classes to supply your own network subclasses which will have their own non-default configuration.  When using your own network classes, you can override the </span><span class="s26">getPrefixConfiguration() </span><span class="s7">method of </span><span class="s9">AddressNetwork</span><span class="s26"> </span><span class="s7">to avoid using the default configuration setting and use your own.  In your network, you will also need to override either the </span><span class="s9">createAddressCreator() </span><span class="s7">or </span><span class="s9">getAddressCreator() </span><span class="s7">methods to supply your own address creator subclass instance that will create your own address and address component classes.</span></p>
<p class="p30"><span class="s7">The following example shows how to create an IPAddressString that will use a customized network class along with customized address component classes:</span></p>
<p class="p16"><span class="s7">     <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>class</b></span><span class="s7"> MyIPv6Address </span><span class="s20"><b>extends</b></span><span class="s7"> IPv6Address {</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>public</b></span><span class="s7"> MyIPv6Address(</span><span class="s20"><b>byte</b></span><span class="s7">[] </span><span class="s19">bytes</span><span class="s7">, Integer </span><span class="s19">prefixLength</span><span class="s7">) {</span></p>
<p class="p23"><span class="s14">            </span><span class="s20"><b>super</b></span><span class="s14">(</span><span class="s7">bytes</span><span class="s14">, </span><span class="s7">prefixLength</span><span class="s14">);</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>public</b></span><span class="s7"> MyIPv6Address(MyIPv6AddressSection </span><span class="s19">section</span><span class="s7">, CharSequence </span><span class="s19">zone</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">            </span><span class="s20"><b>super</b></span><span class="s7">(</span><span class="s19">section</span><span class="s7">, </span><span class="s19">zone</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>public</b></span><span class="s7"> MyIPv6Address(MyIPv6AddressSection </span><span class="s19">section</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">            </span><span class="s20"><b>super</b></span><span class="s7">(</span><span class="s19">section</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p31"><span class="s14">      </span><span class="s7">@Override</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>public</b></span><span class="s7"> IPv6AddressNetwork getNetwork() {</span></p>
<p class="p16"><span class="s7">            </span><span class="s20"><b>return</b></span><span class="s7"> </span><span class="s22">myIPv6Network</span><span class="s7">;</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">     <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>class</b></span><span class="s7"> MyIPv6AddressSection </span><span class="s20"><b>extends</b></span><span class="s7"> IPv6AddressSection {</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>public</b></span><span class="s7"> MyIPv6AddressSection(</span><span class="s20"><b>byte</b></span><span class="s7">[] </span><span class="s19">bytes</span><span class="s7">, Integer </span><span class="s19">prefixLength</span><span class="s7">) {</span></p>
<p class="p23"><span class="s14">            </span><span class="s20"><b>super</b></span><span class="s14">(</span><span class="s7">bytes</span><span class="s14">, </span><span class="s7">prefixLength</span><span class="s14">);</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>public</b></span><span class="s7"> MyIPv6AddressSection(IPv6AddressSegment[] </span><span class="s19">segments</span><span class="s7">, </span><span class="s20"><b>int</b></span><span class="s7"> </span><span class="s19">startIndex</span><span class="s7">, </span><span class="s20"><b>boolean</b></span><span class="s7"> </span><span class="s19">cloneSegments</span><span class="s7">) {</span></p>
<p class="p23"><span class="s14">            </span><span class="s20"><b>super</b></span><span class="s14">(</span><span class="s7">segments</span><span class="s14">, </span><span class="s7">startIndex</span><span class="s14">, </span><span class="s7">cloneSegments</span><span class="s14">);</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>public</b></span><span class="s7"> MyIPv6AddressSection(IPv6AddressSegment[] </span><span class="s19">segments</span><span class="s7">, Integer </span><span class="s19">prefixLength</span><span class="s7">) {</span></p>
<p class="p23"><span class="s14">            </span><span class="s20"><b>super</b></span><span class="s14">(</span><span class="s7">segments</span><span class="s14">, </span><span class="s7">prefixLength</span><span class="s14">);</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p31"><span class="s14">      </span><span class="s7">@Override</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>public</b></span><span class="s7"> IPv6AddressNetwork getNetwork() {</span></p>
<p class="p16"><span class="s7">            </span><span class="s20"><b>return</b></span><span class="s7"> </span><span class="s22">myIPv6Network</span><span class="s7">;</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>class</b></span><span class="s7"> MyIPv6AddressSegment </span><span class="s20"><b>extends</b></span><span class="s7"> IPv6AddressSegment {</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>public</b></span><span class="s7"> MyIPv6AddressSegment(</span><span class="s20"><b>int</b></span><span class="s7"> </span><span class="s19">lower</span><span class="s7">, Integer </span><span class="s19">segmentPrefixLength</span><span class="s7">) {</span></p>
<p class="p23"><span class="s14">            </span><span class="s20"><b>super</b></span><span class="s14">(</span><span class="s7">lower</span><span class="s14">, </span><span class="s7">segmentPrefixLength</span><span class="s14">);</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>public</b></span><span class="s7"> MyIPv6AddressSegment(</span><span class="s20"><b>int</b></span><span class="s7"> </span><span class="s19">lower</span><span class="s7">, </span><span class="s20"><b>int</b></span><span class="s7"> </span><span class="s19">upper</span><span class="s7">, Integer </span><span class="s19">segmentPrefixLength</span><span class="s7">) {</span></p>
<p class="p23"><span class="s14">            </span><span class="s20"><b>super</b></span><span class="s14">(</span><span class="s7">lower</span><span class="s14">, </span><span class="s7">upper</span><span class="s14">, </span><span class="s7">segmentPrefixLength</span><span class="s14">);</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p31"><span class="s14">      </span><span class="s7">@Override</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>public</b></span><span class="s7"> IPv6AddressNetwork getNetwork() {</span></p>
<p class="p16"><span class="s7">            </span><span class="s20"><b>return</b></span><span class="s7"> </span><span class="s22">myIPv6Network</span><span class="s7">;</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">     <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s20"><b>static</b></span><span class="s7"> IPv6AddressNetwork </span><span class="s22">myIPv6Network</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPv6AddressNetwork() {</span></p>
<p class="p31"><span class="s14">      </span><span class="s7">@Override</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>public</b></span><span class="s7"> PrefixConfiguration getPrefixConfiguration() {</span></p>
<p class="p32"><span class="s14">            </span><span class="s20"><b>return</b></span><span class="s14"> PrefixConfiguration.</span><span class="s7"><b>ALL_PREFIXED_ADDRESSES_ARE_SUBNETS</b></span><span class="s14">;</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p31"><span class="s14">      </span><span class="s7">@Override</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>protected</b></span><span class="s7"> IPv6AddressCreator createAddressCreator() {</span></p>
<p class="p16"><span class="s7">            </span><span class="s20"><b>return</b></span><span class="s7"> </span><span class="s20"><b>new</b></span><span class="s7"> IPv6AddressCreator() {</span></p>
<p class="p16"><span class="s7">                  </span><span class="s27">@Override</span></p>
<p class="p16"><span class="s7">                  </span><span class="s20"><b>public</b></span><span class="s7"> IPv6AddressSection createSection(</span><span class="s20"><b>byte</b></span><span class="s7"> </span><span class="s19">bytes</span><span class="s7">[], Integer </span><span class="s19">prefix</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">                        </span><span class="s20"><b>return</b></span><span class="s7"> </span><span class="s20"><b>new</b></span><span class="s7"> MyIPv6AddressSection(</span><span class="s19">bytes</span><span class="s7">, </span><span class="s19">prefix</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">                  }</span></p>
<p class="p16"><span class="s7">                       <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">                  </span><span class="s27">@Override</span></p>
<p class="p16"><span class="s7">                  </span><span class="s20"><b>public</b></span><span class="s7"> IPv6AddressSegment createSegment(</span><span class="s20"><b>int</b></span><span class="s7"> </span><span class="s19">value</span><span class="s7">, Integer </span><span class="s19">segmentPrefixLength</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">                        </span><span class="s20"><b>return</b></span><span class="s7"> </span><span class="s20"><b>new</b></span><span class="s7"> MyIPv6AddressSegment(</span><span class="s19">value</span><span class="s7">, </span><span class="s19">segmentPrefixLength</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">                  }</span></p>
<p class="p16"><span class="s7">                       <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">                  </span><span class="s27">@Override</span></p>
<p class="p16"><span class="s7">                  </span><span class="s20"><b>public</b></span><span class="s7"> IPv6AddressSegment createSegment(</span><span class="s20"><b>int</b></span><span class="s7"> </span><span class="s19">lower</span><span class="s7">, </span><span class="s20"><b>int</b></span><span class="s7"> </span><span class="s19">upper</span><span class="s7">, Integer </span><span class="s19">segmentPrefixLength</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">                        </span><span class="s20"><b>return</b></span><span class="s7"> </span><span class="s20"><b>new</b></span><span class="s7"> MyIPv6AddressSegment(</span><span class="s19">lower</span><span class="s7">, </span><span class="s19">upper</span><span class="s7">, </span><span class="s19">segmentPrefixLength</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">                  }</span></p>
<p class="p16"><span class="s7">                       <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">                  </span><span class="s27">@Override</span></p>
<p class="p16"><span class="s7">                  </span><span class="s20"><b>protected</b></span><span class="s7"> IPv6AddressSegment createSegmentInternal(</span><span class="s20"><b>int</b></span><span class="s7"> </span><span class="s19">value</span><span class="s7">, Integer </span><span class="s19">segmentPrefixLength</span><span class="s7">, CharSequence </span><span class="s19">addressStr</span><span class="s7">, </span><span class="s20"><b>int</b></span><span class="s7"> </span><span class="s19">originalVal</span><span class="s7">,<span class="Apple-converted-space"> </span></span></p>
<p class="p23"><span class="s14">                              </span><span class="s20"><b>boolean</b></span><span class="s14"> </span><span class="s7">isStandardString</span><span class="s14">, </span><span class="s20"><b>int</b></span><span class="s14"> </span><span class="s7">lowerStringStartIndex</span><span class="s14">, </span><span class="s20"><b>int</b></span><span class="s14"> </span><span class="s7">lowerStringEndIndex</span><span class="s14">) {</span></p>
<p class="p16"><span class="s7">                        </span><span class="s20"><b>return</b></span><span class="s7"> </span><span class="s20"><b>new</b></span><span class="s7"> MyIPv6AddressSegment(</span><span class="s19">value</span><span class="s7">, </span><span class="s19">segmentPrefixLength</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">                  }</span></p>
<p class="p16"><span class="s7">                       <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">                  </span><span class="s27">@Override</span></p>
<p class="p16"><span class="s7">                  </span><span class="s20"><b>protected</b></span><span class="s7"> IPv6AddressSection createPrefixedSectionInternal(IPv6AddressSegment </span><span class="s19">segments</span><span class="s7">[], Integer </span><span class="s19">prefix</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">                        </span><span class="s20"><b>return</b></span><span class="s7"> </span><span class="s20"><b>new</b></span><span class="s7"> MyIPv6AddressSection(</span><span class="s19">segments</span><span class="s7">, </span><span class="s19">prefix</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">                  }</span></p>
<p class="p16"><span class="s7">                       <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">                  </span><span class="s27">@Override</span></p>
<p class="p16"><span class="s7">                  </span><span class="s20"><b>protected</b></span><span class="s7"> IPv6AddressSection createSectionInternal(IPv6AddressSegment </span><span class="s19">segments</span><span class="s7">[]) {</span></p>
<p class="p16"><span class="s7">                        </span><span class="s20"><b>return</b></span><span class="s7"> </span><span class="s20"><b>new</b></span><span class="s7"> MyIPv6AddressSection(</span><span class="s19">segments</span><span class="s7">, 0, </span><span class="s20"><b>false</b></span><span class="s7">);</span></p>
<p class="p16"><span class="s7">                  }</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">                  </span><span class="s27">@Override</span></p>
<p class="p16"><span class="s7">                  </span><span class="s20"><b>protected</b></span><span class="s7"> IPv6Address createAddressInternal(IPv6AddressSection </span><span class="s19">section</span><span class="s7">, HostIdentifierString </span><span class="s19">from</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">                        </span><span class="s20"><b>return</b></span><span class="s7"> </span><span class="s20"><b>new</b></span><span class="s7"> MyIPv6Address((MyIPv6AddressSection) </span><span class="s19">section</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">                  }</span></p>
<p class="p16"><span class="s7">                       <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">                  </span><span class="s27">@Override</span></p>
<p class="p16"><span class="s7">                  </span><span class="s20"><b>protected</b></span><span class="s7"> IPv6Address createAddressInternal(IPv6AddressSection </span><span class="s19">section</span><span class="s7">, CharSequence </span><span class="s19">zone</span><span class="s7">, HostIdentifierString </span><span class="s19">from</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">                        </span><span class="s20"><b>return</b></span><span class="s7"> </span><span class="s20"><b>new</b></span><span class="s7"> MyIPv6Address((MyIPv6AddressSection) </span><span class="s19">section</span><span class="s7">, </span><span class="s19">zone</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">                  }</span></p>
<p class="p16"><span class="s7">            };</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p33"><span class="s7">};</span></p>
<p class="p34"><span class="s7"> </span></p>
<p class="p16"><span class="s28">IPAddressStringParameters</span><span class="s7"> </span><span class="s19">params</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> </span><span class="s28">IPAddressStringParameters</span><span class="s7">.Builder().</span></p>
<p class="p21"><span class="s7">getIPv6AddressParametersBuilder().setNetwork(</span><span class="s22">myIPv6Network</span><span class="s7">).getParentBuilder().toParams();</span></p>
<p class="p33"><span class="s7">IPv6Address </span><span class="s19">myAddr</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"1::1/64"</span><span class="s7">, </span><span class="s19">params</span><span class="s7">).getAddress().toIPv6();</span></p>
<p class="p34"><span class="s7"> </span></p>
<p class="p34"><span class="s7"> </span></p>
<p class="p34"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #1a1a1a; -webkit-text-stroke: #1a1a1a"><span class="s7">Address Sections</span></h2>
<p class="p8"><span class="s7">Addresses can be broken up into sections, and reconstituted from sections.  A section is a series of segments.  You can get the section for the full address by calling </span><span class="s9">getSection()</span><span class="s7">, or you can get subsections by calling one of the variants, either </span><span class="s9">getSection(int)</span><span class="s7"> or </span><span class="s9">getSection(int, int)</span><span class="s7">, which return a subsection spanning the given indices.  You can also get the segments in an address by calling </span><span class="s9">getSegment(int) </span><span class="s7">or one of the variants of </span><span class="s9">getSegments</span><span class="s7">, either on the address or on a section of the address.</span></p>
<p class="p8"><span class="s7">You can also reconstitute an address from a section or array of segments using the appropriate address constructor, if your section or array of segments has the correct number of segments for the address type.</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><b>Host and Network Sections of IP Address</b></span></p>
<p class="p8"><span class="s7">Use </span><span class="s9">getHostSection()</span><span class="s7"> and </span><span class="s9">getNetworkSection()</span><span class="s7"> to get the host and network sections of an IP address as indicated by prefix length. <span class="Apple-converted-space"> </span></span></p>
<p class="p15"><span class="s7">IPAddress </span><span class="s19">address</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"1.2.3.4"</span><span class="s7">).getAddress();<br>
IPAddressSection </span><span class="s19">network</span><span class="s7"> = </span><span class="s19">address</span><span class="s7">.getNetworkSection(16, </span><span class="s20"><b>true</b></span><span class="s7">);<br>
IPAddressSection </span><span class="s19">host</span><span class="s7"> = </span><span class="s19">address</span><span class="s7">.getHostSection(16);<br>
System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">network</span><span class="s7">.toCanonicalString());<br>
System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">host</span><span class="s7">.toCanonicalString());</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7">Output:</span></p>
<p class="p15"><span class="s7">1.2/16</span></p>
<p class="p16"><span class="s7">3.4</span></p>
<p class="p8"><span class="s7">Once you have a section of an address, most of the same methods are available as those available with addresses themselves.</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p14"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #b40004; -webkit-text-stroke: #b40004"><span class="s7">IP Address Operations</span></h2>
<p class="p8"><span class="s7">There are various methods for masking, obtaining subnets, and so on.</span></p>
<p class="p35"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><b>Summary of IP Address Operations</b></span></p>
<p class="p8"><span class="s7">Here is a summary, a non-exhaustive list, in no specific order, of operations for transforming addresses and subnets:</span></p>
<p class="p9"><span class="s11">·</span><span class="s10">      </span><span class="s9"><b>toPrefixBlock</b></span><span class="s13">: </span><span class="s7">Provides the subnet for the entire prefix block using the existing or a supplied prefix length (</span><span class="s9">toPrefixBlock</span><span class="s7"> is redundant when using prefix configuration </span><span class="s26">ALL_PREFIXED_ADDRESSES_ARE_SUBNETS </span><span class="s7">because prefixed addresses are always a prefix block with that configuration).  You can use </span><span class="s9">isPrefixBlock</span><span class="s7"> to determine if the operation would have no effect on the address because it is already a prefix block.</span></p>
<p class="p9"><span class="s11">·</span><span class="s10">      </span><span class="s26"><b>assignPrefixForSingleBlock</b> </span><span class="s7">(formerly </span><span class="s26">toPrefixedEquivalent</span><span class="s7">): Converts a subnet address with no prefix length to an equivalent address with a prefix length.  The resulting address will span the same range of values as the original.  You can use </span><span class="s26">getPrefixLengthForSingleBlock </span><span class="s7">(formerly </span><span class="s26">getEquivalentPrefix</span><span class="s7">)</span><span class="s26"> </span><span class="s7">to get the resultant prefix prior to the operation, or </span><span class="s26">isSinglePrefixBlock </span><span class="s7">(formerly </span><span class="s26">isRangeEquivalentToPrefix</span><span class="s7">)</span><span class="s26"> </span><span class="s7">to determine if the operation would have no effect on the address because it is already a single prefix block.</span></p>
<p class="p9"><span class="s11">·</span><span class="s10">      </span><span class="s26"><b>assignMinPrefixForBlock</b> </span><span class="s7">(formerly </span><span class="s26">toMinPrefixedEquivalent</span><span class="s7">): Converts an address to an equivalent address with the smallest possible prefix length.  The resulting address will span the same range of values as the original.  You can use </span><span class="s26">getMinPrefixLengthForBlock </span><span class="s7">(formerly </span><span class="s26">getMinPrefix</span><span class="s7">)</span><span class="s26"> </span><span class="s7">to get the resultant prefix prior to the operation.</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>mergeToPrefixBlocks, mergeToSequentialBlocks</b></span><span class="s7">: Given a list of addresses or subnets, merges them into the minimal list of prefix block subnets or sequential block subnets</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>join</b></span><span class="s7">: Given a list of address ranges, merges them into the minimal list of address ranges</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>spanWithPrefixBlocks, spanWithSequentialBLocks</b></span><span class="s7">: Given a pair of addresses or subnets, finds the minimal list of prefix block subnets or sequential block subnets that span all addresses between the pair<span class="Apple-converted-space"> </span></span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s29"><b>append</b></span><span class="s24">,</span><span class="s29"> <b>prepend</b></span><span class="s24">,</span><span class="s29"> <b>replace</b></span><span class="s24">: Add or replace segments in sections and addresses.  </span><span class="s7">On addresses you must always maintain the correct number of segments, so only the replace operation is provided.  You can obtain a section by either constructing one directly or by calling a variant of </span><span class="s29">getSection</span><span class="s7"> on an address.</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>adjustPrefixBySegment</b></span><span class="s7">: Will create a larger network or smaller subnet address by increasing or decreasing the prefix length to the next segment boundary. If prefix length is increased, the additional prefix bits can be either zero or the full range of potential values.<span class="Apple-converted-space"> </span></span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s29"><b>withoutPrefixLength </b></span><span class="s7">Convert to the same address but with no prefix length</span></p>
<p class="p9"><span class="s11">·</span><span class="s10">      </span><span class="s9"><b>removePrefixLength</b></span><span class="s30">, </span><span class="s9"><b>adjustPrefixLength</b></span><span class="s30">, </span><span class="s9"><b>applyPrefixLength</b></span><span class="s30">, </span><span class="s9"><b>setPrefixLength</b></span><span class="s7">:  Add, remove or adjust prefix lengths by the indicated values.  There are variants with a boolean argument to control whether extended prefix lengths have zeros for the added bits, or whether the bits retain their values from when they were on the other side of the prefix boundary.  The default behavior when extending a prefix length is to insert zeros in the bits added to the prefix.  The difference between </span><span class="s9">applyPrefixLength</span><span class="s30"> </span><span class="s7">and </span><span class="s9">setPrefixLength</span><span class="s7"> is that the former does not shorten a prefix length. </span><span class="s9">applyPrefixLength</span><span class="s7"> will not decrease the size of a subnet.  </span><span class="s9">removePrefixLength</span><span class="s7"> is like </span><span class="s9">withoutPrefixLength</span><span class="s7"> but will convert the former host bits to zero</span></p>
<p class="p9"><span class="s11">·</span><span class="s10">      </span><span class="s9"><b>mask</b></span><span class="s30">,</span><span class="s9"> <b>maskNetwork</b></span><span class="s30">,</span><span class="s9"> <b>bitwiseOr</b></span><span class="s30">,</span><span class="s9"> <b>bitwiseOrNetwork</b></span><span class="s7">: apply masks to subnets and addresses.  The “network” variants allow you to mask just the network portion and apply a prefix length, while the others remove any existing prefix length.</span></p>
<p class="p9"><span class="s11">·</span><span class="s10">      </span><span class="s9"><b>reverseBits</b></span><span class="s30">,</span><span class="s9"> <b>reverseBytes</b></span><span class="s30">,</span><span class="s9"> <b>reverseBytesPerSegment</b></span><span class="s30">,</span><span class="s9"> <b>reverseSegments</b></span><span class="s7">: useful for handling endianness (network byte order sometimes requires bytes be reversed), or DNS lookup, or other reasons for reversing bits and bytes.</span></p>
<p class="p9"><span class="s11">·</span><span class="s10">      </span><span class="s9"><b>subtract</b></span><span class="s7">: Computes the subnet difference, the set of addresses in the subnet but not in the argument subnet. Subtracts a given subnet from the receiver subnet, returning an array of subnets for the result.</span></p>
<p class="p9"><span class="s11">·</span><span class="s10">      </span><span class="s9"><b>intersect</b></span><span class="s7">: Computes the subnet conjunction, the set of addresses in both the receiver subnet and the argument subnet.</span></p>
<p class="p9"><span class="s11">·</span><span class="s10">      </span><span class="s9"><b>increment</b></span><span class="s7">: Given a positive or negative integer increment value, if the address is a subnet, provides the address that is the given increment into the list of subnet addresses.  Any increment exceeding the count of addresses in the subnet is simply added to the final address in the subnet.  If the address is an individual address, adds the given increment to the address value to produce a new address.</span></p>
<p class="p9"><span class="s11">·</span><span class="s10">      </span><span class="s9"><b>toIPv4, toIPv6, toEUI</b></span><span class="s13">: </span><span class="s7">Use either standard or customized address conversions to go from one address version/type to another</span></p>
<p class="p9"><span class="s11">·</span><span class="s10">      </span><span class="s9"><b>iterator</b></span><span class="s7">: iterates through the individual addresses of a subnet</span></p>
<p class="p9"><span class="s11">·</span><span class="s10">      </span><span class="s9"><b>prefixBlockIterator</b></span><span class="s13">: </span><span class="s7">iterates through the individual prefix block subnets of a larger subnet</span></p>
<p class="p14"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><b>Queries for Prefix Lengths and Prefix Blocks</b></span></p>
<p class="p8"><span class="s7">In some cases you may need to know if you have a prefix block subnet, such as the /64 block a:b:c:d::/64 or the /16 block 1.2.0.0/16, in which the subnet contains all the addresses with the same prefix of a given length.  The following methods allow you to query for prefix blocks and lengths of blocks.</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>containsPrefixBlock</b></span><span class="s7">: Answers whether the subnet contains the prefix block of addresses for a given prefix length (regardless of whether the address is assigned a different prefix length or has none assigned).</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>containsSinglePrefixBlock</b></span><span class="s7">: Like </span><span class="s9">containsPrefixBlock</span><span class="s7">, but queries if the subnet contains only the prefix block of addresses for a given prefix length.  In other words, it answers whether the subnet contains the full block of address for just a single prefix<span class="Apple-converted-space"> </span></span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>isPrefixBlock</b></span><span class="s7">: Like </span><span class="s9">containsPrefixBlock</span><span class="s7"> but using the prefix length assigned to the address.</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>isSinglePrefixBlock</b></span><span class="s7">: Like </span><span class="s9">containsSinglePrefixBlock</span><span class="s7"> but using the prefix length assigned to the address</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>getBlockMaskPrefixLength</b></span><span class="s7">:</span><span class="s9"> </span><span class="s24">(formerly </span><span class="s9">getMaskPrefixLength</span><span class="s24">)</span><span class="s7">: Will return the prefix length for a network or host mask, if it is one</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>getPrefixLengthForSingleBlock</b></span><span class="s7">: Returns a prefix length for which the range of this segment grouping matches exactly the block of addresses for that prefix, if such a prefix length exists, and if it does, it will match the result of </span><span class="s9">getMinPrefixLengthForBlock</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>getMinPrefixLengthForBlock</b></span><span class="s7">: Returns the smallest prefix length such that this address division series includes the block of addresses for that prefix, which is the bit count for individual addresses.</span></p>
<p class="p14"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><b>Iterators</b></span></p>
<p class="p8"><span class="s7">Various iterators are available for iterating through subnet in different ways.</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>iterator</b></span><span class="s7">: Iterates through all addresses. Use </span><span class="s9">getCount</span><span class="s7"> to get the iterated count.</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>nonZeroHostIterator</b></span><span class="s7">: Like </span><span class="s9">iterator</span><span class="s7">, but if the subnet has a prefix length, then this skips all zero-valued hosts.  This can be useful because the zero-valued host in a subnet typically represents the subnet as a whole and is typically not used as an individual address. Use </span><span class="s9">getNonZeroHostCount</span><span class="s7"> to get the iterated count.</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>prefixBlockIterator</b></span><span class="s7">: If the subnet has a prefix length, then this iterates through the prefixes, with each iterated item being the prefix block for each prefix.  If no prefix length, same as </span><span class="s9">iterator</span><span class="s7">.  Use </span><span class="s9">getPrefixCount</span><span class="s7"> to get the iterated count.</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>prefixIterator</b></span><span class="s7">: If the subnet has a prefix length, then this iterates through the prefixes, with each iterated item including all the addresses in the original iterated subnet which have the same prefix.  For all iterated items except the lowest and highest this is the prefix block, while the lowest and highest prefix might have fewer addresses than the prefix block.  If no prefix length, same as </span><span class="s9">iterator</span><span class="s7">.  Use </span><span class="s9">getPrefixCount</span><span class="s7"> to get the iterated count.</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>blockIterator</b></span><span class="s7">: Iterates through the segment values of the higher segments up until a given segment index.  If the segment index is 0, produces just a single value, the original address.  If the segment index is the segment count, same as </span><span class="s9">iterator</span><span class="s7">. Like </span><span class="s9">prefixIterator</span><span class="s7">, for each segment prefix, includes all addresses in the original iterated subnet which have that prefix. Use </span><span class="s9">getBlockCount</span><span class="s7"> to get the iterated count.</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>sequentialBlockIterator</b></span><span class="s7">: Iterates through the segment values of the higher segments up until a specific segment index.  The segment index is chosen to be the largest segment index which allows for all iterated address blocks to be sequential. Use </span><span class="s9">getSequentialBlockCount</span><span class="s7"> to get the iterated count.</span></p>
<p class="p14"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><b>Mask and Prefix Length Operations</b></span></p>
<p class="p37"><span class="s12">The methods </span><span class="s7">mask</span><span class="s12">,</span><span class="s7"> maskNetwork</span><span class="s12">,</span><span class="s7"> bitwiseOr</span><span class="s12">,</span><span class="s7"> bitwiseOrNetwork</span><span class="s12">,</span><span class="s7"> removePrefixLength</span><span class="s12">,</span><span class="s7"> adjustPrefixBySegment</span><span class="s12">,</span><span class="s7"> adjustPrefixLength</span><span class="s12">,</span><span class="s7"> applyPrefixLength</span><span class="s12">, and </span><span class="s7">setPrefixLength</span><span class="s12"> allow you to apply and adjust prefix lengths, and to apply masks, to addresses and subnets. <span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s7">When applying an operation to a subnet, the operation is applied to every member of the subnet, so the result must be something representable with sequential segment ranges, or you will get </span><span class="s26">IncompatibleAddressException</span><span class="s7"> (formerly </span><span class="s9">AddressTypeException</span><span class="s7">).  For instance, masking the subnet block of 255 addresses 0.0.0.0/24 with 0.0.0.128 results in the two addresses 0.0.0.0 and 0.0.0.128 which is not contiguous.  However, this will not happen when using standard masking and subnetting techniques typical with IPv4 and IPv6 routing. <span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7">The following code demonstrates how to get the lowest address in a prefixed subnet using any one of three methods: </span><span class="s9">getLowest,</span><span class="s7"> </span><span class="s9">mask</span><span class="s7">, or </span><span class="s9">removePrefixLength</span><span class="s7">.</span></p>
<p class="p21"><span class="s7">String </span><span class="s19">addr</span><span class="s7"> = </span><span class="s21">"1.2.3.4"</span><span class="s7">;</span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">address</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s19">addr</span><span class="s7">).getAddress();</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>int</b></span><span class="s7"> </span><span class="s19">prefixLength</span><span class="s7"> = 16;</span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">maskWithPrefixLength</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"/"</span><span class="s7"> + </span><span class="s19">prefixLength</span><span class="s7">).</span></p>
<p class="p16"><span class="s7">            getAddress(</span><span class="s19">address</span><span class="s7">.getIPVersion());</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">mask</span><span class="s7"> = </span><span class="s19">address</span><span class="s7">.getNetwork().getNetworkMask(16, </span><span class="s20"><b>false</b></span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"mask with prefix length "</span><span class="s7"> + </span><span class="s19">maskWithPrefixLength</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"mask "</span><span class="s7"> + </span><span class="s19">mask</span><span class="s7">);</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p38"><span class="s14">IPAddress </span><span class="s7">maskedAddress</span><span class="s14"> = </span><span class="s7">address</span><span class="s14">.mask(</span><span class="s7">mask</span><span class="s14">);</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"address "</span><span class="s7"> + </span><span class="s19">address</span><span class="s7"> + </span><span class="s21">" masked "</span><span class="s7"> + </span><span class="s19">maskedAddress</span><span class="s7">);</span></p>
<p class="p5"><span class="s7"> </span></p>
<p class="p39"><span class="s7">//create the subnet</span></p>
<p class="p21"><span class="s7">IPAddress </span><span class="s19">subnet</span><span class="s7"> = </span><span class="s19">address</span><span class="s7">.applyPrefixLength(</span><span class="s19">prefixLength</span><span class="s7">).toPrefixBlock();</span></p>
<p class="p21"><span class="s7"> </span></p>
<p class="p39"><span class="s7">//mask</span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">maskedSubnet</span><span class="s7"> = </span><span class="s19">subnet</span><span class="s7">.mask(</span><span class="s19">mask</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"subnet "</span><span class="s7"> + </span><span class="s19">subnet</span><span class="s7"> + </span><span class="s21">" masked "</span><span class="s7"> + </span><span class="s19">maskedSubnet</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">maskedAddress</span><span class="s7">.equals(</span><span class="s19">maskedSubnet</span><span class="s7">));</span></p>
<p class="p16"><span class="s7">     <span class="Apple-converted-space"> </span></span></p>
<p class="p17"><span class="s14">      </span><span class="s7">//getLower</span></p>
<p class="p38"><span class="s14">IPAddress </span><span class="s7">lowestAddressInSubnet</span><span class="s14"> = </span><span class="s7">subnet</span><span class="s14">.getLower();</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"lowest in subnet "</span><span class="s7"> + </span><span class="s19">lowestAddressInSubnet</span><span class="s7">);</span></p>
<p class="p21"><span class="s7">System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"lowest in subnet no prefix "</span><span class="s7"> + </span><span class="s19">lowestAddressInSubnet</span><span class="s7">.removePrefixLength(</span><span class="s20"><b>false</b></span><span class="s7">));</span></p>
<p class="p38"><span class="s14">System.</span><span class="s22"><b>out</b></span><span class="s14">.println(</span><span class="s7">maskedAddress</span><span class="s14">.equals(</span><span class="s7">lowestAddressInSubnet</span><span class="s14">));</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p39"><span class="s7">//removePrefixLength</span></p>
<p class="p21"><span class="s7">IPAddress </span><span class="s19">prefixRemoved</span><span class="s7"> = </span><span class="s19">subnet</span><span class="s7">.removePrefixLength(</span><span class="s20"><b>true</b></span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"prefix removed "</span><span class="s7"> + </span><span class="s19">prefixRemoved</span><span class="s7">);</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p8"><span class="s7">Output:</span></p>
<p class="p16"><span class="s7">mask with prefix length 255.255.0.0/16</span></p>
<p class="p16"><span class="s7">mask 255.255.0.0</span></p>
<p class="p16"><span class="s7">address 1.2.3.4 masked 1.2.0.0</span></p>
<p class="p16"><span class="s7">subnet 1.2.0.0/16 masked 1.2.0.0</span></p>
<p class="p16"><span class="s7">true</span></p>
<p class="p16"><span class="s7">lowest in subnet 1.2.0.0/16</span></p>
<p class="p16"><span class="s7">lowest in subnet no prefix 1.2.0.0</span></p>
<p class="p16"><span class="s7">true</span></p>
<p class="p16"><span class="s7">prefix removed 1.2.0.0</span></p>
<p class="p5"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><b>Polymorphism</b></span></p>
<p class="p8"><span class="s7">Simply change the string </span><span class="s31">"1.2.3.4"</span><span class="s7"> in the code above to an IPv6 address like </span><span class="s31">"a:ffff:b:c:d::f"</span><span class="s7"> and the code all works the same.</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7">Output:</span></p>
<p class="p16"><span class="s7">mask with prefix length ffff::/16</span></p>
<p class="p16"><span class="s7">mask ffff::</span></p>
<p class="p16"><span class="s7">address a:ffff:b:c:d::f masked a::</span></p>
<p class="p16"><span class="s7">subnet a::/16 masked a::</span></p>
<p class="p16"><span class="s7">true</span></p>
<p class="p16"><span class="s7">lowest in subnet a::/16</span></p>
<p class="p16"><span class="s7">lowest in subnet no prefix a::</span></p>
<p class="p16"><span class="s7">true<br>
prefix removed a::</span><span class="s17"><br>
<br>
</span></p>
<p class="p8"><span class="s7"><b>Subnetting<span class="Apple-converted-space"> </span></b></span></p>
<p class="p8"><span class="s7">Subnetting can be accomplished using various address manipulation methods.   Given a prefixed IP address, you can extend the prefix length and insert bits for an extended prefix and new subnet of the previous address block, as shown in the following example.</span></p>
<p class="p38"><span class="s20"><b>int</b></span><span class="s14"> </span><span class="s7">originalPrefix</span><span class="s14"> = 18, </span><span class="s7">adjustment</span><span class="s14"> = 4;</span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">address</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"207.0.64.0"</span><span class="s7">).getAddress();</span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">address2</span><span class="s7"> = </span><span class="s19">address</span><span class="s7">.setPrefixLength(</span><span class="s19">originalPrefix</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">prefixExtension</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"0.0.4.0"</span><span class="s7">).getAddress();</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">subnet1</span><span class="s7"> = </span><span class="s19">address2</span><span class="s7">.adjustPrefixLength(</span><span class="s19">adjustment</span><span class="s7">);</span><span class="s25">//extend the prefix length</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">subnet1</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p40"><span class="s14">IPAddress </span><span class="s7">subnet2</span><span class="s14"> = </span><span class="s7">subnet1</span><span class="s14">.bitwiseOrNetwork(</span><span class="s7">prefixExtension</span><span class="s14">, </span><span class="s7">originalPrefix</span><span class="s14"> + </span><span class="s7">adjustment</span><span class="s14">); </span><span class="s25">//adjust the extended prefix<br>
</span><span class="s14">System.</span><span class="s22"><b>out</b></span><span class="s14">.println(</span><span class="s7">subnet2</span><span class="s14">);</span></p>
<p class="p15"><span class="s7"> </span></p>
<p class="p16"><span class="s17">Output:<br>
</span><span class="s7">207.0.64.0/18</span></p>
<p class="p16"><span class="s7">207.0.64.0/22</span></p>
<p class="p16"><span class="s7">207.0.68.0/22</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p8"><span class="s7">Here is the same subnetting operation using segment replacement:</span></p>
<p class="p21"><span class="s7">IPv4Address </span><span class="s19">address</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"207.0.64.0/18"</span><span class="s7">).getAddress().toIPv4();</span></p>
<p class="p16"><span class="s7">      IPv4AddressSection </span><span class="s19">replacementSection</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"0.0.68.0/22"</span><span class="s7">).getAddress().toIPv4().getSection(2);</span></p>
<p class="p24"><span class="s7">IPAddress </span><span class="s19">subnet</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPv4Address(</span><span class="s19">address</span><span class="s7">.getSection().replace(2, </span><span class="s19">replacementSection</span><span class="s7">));<br>
System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">subnet</span><span class="s7">);</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p16"><span class="s17">Output:</span><span class="s7"><br>
207.0.68.0/22</span></p>
<p class="p41"><span class="s7"> </span></p>
<p class="p5"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Alternatively, you can use the </span><span class="s9">prefixBlockIterator()</span><span class="s7"> method to get a list of subnets when adjusting the prefix:</span></p>
<p class="p5"><span class="s7"> </span></p>
<p class="p21"><span class="s7">IPAddress </span><span class="s19">subnet</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"192.168.0.0/28"</span><span class="s7">).getAddress();</span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">newSubnets</span><span class="s7"> = </span><span class="s19">subnet</span><span class="s7">.setPrefixLength(</span><span class="s19">subnet</span><span class="s7">.getPrefixLength() + 2, </span><span class="s20"><b>false</b></span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">newSubnets</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      TreeSet&lt;IPAddress&gt; </span><span class="s19">subnetSet</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> TreeSet&lt;IPAddress&gt;();</span></p>
<p class="p16"><span class="s7">      Iterator&lt;? </span><span class="s20"><b>extends</b></span><span class="s7"> IPAddress&gt; </span><span class="s19">iterator</span><span class="s7"> = </span><span class="s19">newSubnets</span><span class="s7">.prefixBlockIterator();</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>while</b></span><span class="s7"> (</span><span class="s19">iterator</span><span class="s7">.hasNext()) {</span></p>
<p class="p16"><span class="s7">          </span><span class="s19">subnetSet</span><span class="s7">.add(</span><span class="s19">iterator</span><span class="s7">.next());</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">subnetSet</span><span class="s7">);</span></p>
<p class="p5"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Output:</span></p>
<p class="p16"><span class="s7">192.168.0.0-12/30</span></p>
<p class="p16"><span class="s7">[192.168.0.0/30, 192.168.0.4/30, 192.168.0.8/30, 192.168.0.12/30]</span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 20.0px; font: 16.0px Arial; color: #b40004; -webkit-text-stroke: #b40004"><span class="s7"> </span></h2>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #1a1a1a; -webkit-text-stroke: #1a1a1a"><span class="s7">IP Address Ranges</span></h2>
<p class="p18"><span class="s7">An </span><span class="s9">IPAddress</span><span class="s7"> or </span><span class="s9">IPAddressString</span><span class="s7"> instance can represent any individual address or any range of addresses in which each segment specifies its own range of sequential values.  For </span><span class="s9">IPAddress, </span><span class="s7">the ranges are specified with the canonical number of segments for each address version or type, which is 4 segments for IPv4, 8 for IPv6, and either 6 or 8 for MAC. <span class="Apple-converted-space"> </span></span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Any prefix block of addresses can be specified this way (a block of addresses that includes all the hosts for a given prefix). <span class="Apple-converted-space"> </span></span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">An </span><span class="s9">IPAddressString</span><span class="s7"> can represent any such address string, even those that do not use the canonical number of segments.  However, for ranges involving a non-canonical number of segments, converting to an </span><span class="s9">IPAddress</span><span class="s7"> instance is not always possible (for example the IPv4 subnet 1.2-3.0-1000 cannot be expressed with 4 segments).</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Not all </span><span class="s9">IPAddress</span><span class="s7"> subnets are sequential.  For instance, 1-2.3.4-5.6 is not sequential, since the address 1.3.4.6 is followed in the block by 1.3.5.6 while the next sequential address 1.3.4.7 is not part of the block.  A sequential block is one in which the range is sequential.  For a block to be sequential, the first segment with a range of values must be followed only by segments that cover all values.  For instance, 1.2.3-4.* is a sequential block, as well as 1:a-f:*:*:*:*:*:*, also writeable as 1:a-f:*.  Any prefix block is sequential and can also be expressed without the prefix length.  For instance, the prefix block 1:2:3:4::/64 can be written without the prefix length as 1:2:3:4:*.</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">You can convert a non-sequential block to a collection of sequential blocks using the </span><span class="s9">sequentialBlockIterator</span><span class="s7"> method of </span><span class="s9">IPAddress</span><span class="s7">.  If you wish to get the count of sequential blocks, use the methods </span><span class="s9">getPrefixCount</span><span class="s7"> or </span><span class="s9">getSequentialBlockCount</span><span class="s7">.</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p16"><span class="s7">convertNonSequentialBlock(</span><span class="s21">"a:b:c:d:1:2-4:3-5:4-6"</span><span class="s7">);</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> convertNonSequentialBlock(String </span><span class="s19">string</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">      IPAddressString </span><span class="s19">addrString</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s19">string</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">addr</span><span class="s7"> = </span><span class="s19">addrString</span><span class="s7">.getAddress();</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"Initial range block is "</span><span class="s7"> + </span><span class="s19">addr</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      BigInteger </span><span class="s19">sequentialCount</span><span class="s7"> = </span><span class="s19">addr</span><span class="s7">.getSequentialBlockCount();</span></p>
<p class="p20"><span class="s14">      System.</span><span class="s22"><b>out</b></span><span class="s14">.println(</span><span class="s7">"Sequential range block count is "</span><span class="s14"> +<span class="Apple-converted-space"> </span></span></p>
<p class="p43"><span class="s7">sequentialCount</span><span class="s14">);</span></p>
<p class="p16"><span class="s7">      Iterator&lt;? </span><span class="s20"><b>extends</b></span><span class="s7"> IPAddress&gt; </span><span class="s19">iterator</span><span class="s7"> =<span class="Apple-converted-space"> </span></span></p>
<p class="p44"><span class="s19">addr</span><span class="s7">.sequentialBlockIterator();</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>while</b></span><span class="s7">(</span><span class="s19">iterator</span><span class="s7">.hasNext()) {</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">iterator</span><span class="s7">.next());</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Output:</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p16"><span class="s7">Initial range block is a:b:c:d:1:2-4:3-5:4-6</span></p>
<p class="p16"><span class="s7">Sequential range block count is 9</span></p>
<p class="p16"><span class="s7">a:b:c:d:1:2:3:4-6</span></p>
<p class="p16"><span class="s7">a:b:c:d:1:2:4:4-6</span></p>
<p class="p16"><span class="s7">a:b:c:d:1:2:5:4-6</span></p>
<p class="p16"><span class="s7">a:b:c:d:1:3:3:4-6</span></p>
<p class="p16"><span class="s7">a:b:c:d:1:3:4:4-6</span></p>
<p class="p16"><span class="s7">a:b:c:d:1:3:5:4-6</span></p>
<p class="p16"><span class="s7">a:b:c:d:1:4:3:4-6</span></p>
<p class="p16"><span class="s7">a:b:c:d:1:4:4:4-6</span></p>
<p class="p16"><span class="s7">a:b:c:d:1:4:5:4-6</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Not all sequential address ranges can be described by an instance of </span><span class="s9">IPAddress</span><span class="s7"> or </span><span class="s9">IPAddressString</span><span class="s7">.  One such example is the range of two IPv4 addresses from 1.2.3.255 to 1.2.4.0.  One option is to represent the address range with just a single large segment covering the section of the address that has a range of values, such as in an instance of </span><span class="s9">IPAddressLargeDivisionGrouping</span><span class="s7">.</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">The better option is to use an </span><span class="s9">IPAddressSeqRange</span><span class="s7"> instance, which provides a more general representation of address ranges and their associated operations.  You can represent any sequential range of addresses with an </span><span class="s9">IPAddressSeqRange</span><span class="s7"> instance.</span></p>
<p class="p35"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Both</span><span class="s9"> IPAddress</span><span class="s7"> and </span><span class="s9">IPAddressSeqRange</span><span class="s7"> implement the </span><span class="s9">IPAddressRange</span><span class="s7"> interface.</span><span class="s9"> IPAddressSeqRange </span><span class="s7">instances cover all ranges of addresses, while </span><span class="s9">IPAddress</span><span class="s7"> cover all ranges of segments.</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">An </span><span class="s9">IPAddressSeqRange</span><span class="s7"> instance can be converted to the minimal list of sequential blocks or prefix blocks that cover the same range of addresses, so that is a couple of ways to go from </span><span class="s9">IPAddressSeqRange </span><span class="s7">to </span><span class="s9">IPAddress </span><span class="s7">instances.  To go in the reverse direction from </span><span class="s9">IPAddress</span><span class="s7"> to </span><span class="s9">IPAddressSeqRange</span><span class="s7">, you can convert any </span><span class="s9">IPAddress</span><span class="s7"> sequential block or prefix block to an </span><span class="s9">IPAddressRange</span><span class="s7"> with the method </span><span class="s9">toSequentialRange</span><span class="s7">, and then you can join any collection of </span><span class="s9">IPAddressRange</span><span class="s7"> instances with the </span><span class="s9">join</span><span class="s7"> method in  </span><span class="s9">IPAddressSeqRange</span><span class="s7">.</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Here we show a code example of creating a sequential range, breaking it up into either prefix blocks or sequential blocks, and then merging those blocks to get the original sequential range.</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p20"><span class="s14">testSpanAndMerge(</span><span class="s7">"2:3:ffff:5::"</span><span class="s14">, </span><span class="s7">"2:4:1:5::"</span><span class="s14">);</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p16"><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> testSpanAndMerge(String </span><span class="s19">address1</span><span class="s7">, String </span><span class="s19">address2</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">      IPAddressString </span><span class="s19">string1</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s19">address1</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      IPAddressString </span><span class="s19">string2</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s19">address2</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">addr1</span><span class="s7"> = </span><span class="s19">string1</span><span class="s7">.getAddress();</span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">addr2</span><span class="s7"> = </span><span class="s19">string2</span><span class="s7">.getAddress();</span></p>
<p class="p16"><span class="s7">      IPAddressSeqRange </span><span class="s19">range</span><span class="s7"> = </span><span class="s19">addr1</span><span class="s7">.toSequentialRange(</span><span class="s19">addr2</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"Original range of size "</span><span class="s7"> + </span><span class="s19">range</span><span class="s7">.getCount() + </span><span class="s21">": "</span><span class="s7"> + </span><span class="s19">range</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">result</span><span class="s7">[] = </span><span class="s19">range</span><span class="s7">.spanWithPrefixBlocks();</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"Prefix blocks: "</span><span class="s7"> + Arrays.asList(</span><span class="s19">result</span><span class="s7">));</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">result2</span><span class="s7">[] = </span><span class="s19">range</span><span class="s7">.spanWithSequentialBlocks();</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"Sequential blocks: "</span><span class="s7"> + Arrays.asList(</span><span class="s19">result2</span><span class="s7">));</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">      List&lt;IPAddressSeqRange&gt; </span><span class="s19">rangeList</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> ArrayList&lt;&gt;();</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>for</b></span><span class="s7">(IPAddress </span><span class="s19">a</span><span class="s7"> : </span><span class="s19">result</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">            IPAddressSeqRange </span><span class="s19">r</span><span class="s7"> = </span><span class="s19">a</span><span class="s7">.toSequentialRange();</span></p>
<p class="p16"><span class="s7">            </span><span class="s19">rangeList</span><span class="s7">.add(</span><span class="s19">r</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">      IPAddressSeqRange </span><span class="s19">joined</span><span class="s7">[] = IPAddressSeqRange.join(</span></p>
<p class="p44"><span class="s19">rangeList</span><span class="s7">.toArray(</span><span class="s20"><b>new</b></span><span class="s7"> IPAddressSeqRange[</span><span class="s19">rangeList</span><span class="s7">.size()]));</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"Merged prefix blocks back again: "</span><span class="s7"> + Arrays.asList(</span><span class="s19">joined</span><span class="s7">));</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">      </span><span class="s19">rangeList</span><span class="s7">.clear();</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>for</b></span><span class="s7">(IPAddress </span><span class="s19">a</span><span class="s7"> : </span><span class="s19">result2</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">            IPAddressSeqRange </span><span class="s19">r</span><span class="s7"> = </span><span class="s19">a</span><span class="s7">.toSequentialRange();</span></p>
<p class="p16"><span class="s7">            </span><span class="s19">rangeList</span><span class="s7">.add(</span><span class="s19">r</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">      </span><span class="s19">joined</span><span class="s7"> = IPAddressSeqRange.join(</span><span class="s19">rangeList</span><span class="s7">.toArray(</span></p>
<p class="p45"><span class="s20"><b>new</b></span><span class="s7"> IPAddressSeqRange[</span><span class="s19">rangeList</span><span class="s7">.size()]));</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s21">"Merged sequential blocks back again: "</span><span class="s7"> + Arrays.asList(</span><span class="s19">joined</span><span class="s7">));</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Output:</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p16"><span class="s7">Original range of size 2417851639229258349412353: 2:3:ffff:5:: -&gt; 2:4:1:5::</span></p>
<p class="p16"><span class="s7">Prefix blocks: [2:3:ffff:5::/64, 2:3:ffff:6::/63, 2:3:ffff:8::/61, 2:3:ffff:10::/60, 2:3:ffff:20::/59, 2:3:ffff:40::/58, 2:3:ffff:80::/57, 2:3:ffff:100::/56, 2:3:ffff:200::/55, 2:3:ffff:400::/54, 2:3:ffff:800::/53, 2:3:ffff:1000::/52, 2:3:ffff:2000::/51, 2:3:ffff:4000::/50, 2:3:ffff:8000::/49, 2:4::/48, 2:4:1::/62, 2:4:1:4::/64, 2:4:1:5::]</span></p>
<p class="p16"><span class="s7">Sequential blocks: [2:3:ffff:5-ffff:*:*:*:*, 2:3-4:*:*:*:*:*:*, 2:4:0:*:*:*:*:*, 2:4:1:0-4:*:*:*:*, 2:4:1:5::]</span></p>
<p class="p16"><span class="s7">Merged prefix blocks back again: [2:3:ffff:5:: -&gt; 2:4:1:5::]</span></p>
<p class="p16"><span class="s7">Merged sequential blocks back again: [2:3:ffff:5:: -&gt; 2:4:1:5::]</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">As you can see in the example above, you can generally describe a range with fewer sequential blocks than prefix blocks.</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p18"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #b40004; -webkit-text-stroke: #b40004"><span class="s7">Parse String Representations of MAC Address</span></h2>
<p class="p8"><span class="s7">Conversion is like IP address.  </span><span class="s9">MACAddressString</span><span class="s7"> is used to convert.  You can use one of </span><span class="s9">getAddress</span><span class="s7"> or </span><span class="s9">toAddress</span><span class="s7">, the difference being whether parsing errors are handled by exception or not.</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p15"><span class="s7">MACAddress </span><span class="s19">address</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> MACAddressString(</span><span class="s21">"01:02:03:04:0a:0b"</span><span class="s7">).getAddress();</span></p>
<p class="p16"><span class="s20"><b>if</b></span><span class="s7">(</span><span class="s19">address</span><span class="s7"> != </span><span class="s20"><b>null</b></span><span class="s7">) {</span></p>
<p class="p17"><span class="s14">      </span><span class="s7">//use address here</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p18"><span class="s7">or</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p19"><span class="s7"><b>try</b></span><span class="s14"> {</span></p>
<p class="p16"><span class="s7">      MACAddress </span><span class="s19">address</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> MACAddressString (</span><span class="s21">"01:02:03:04:0a:0b"</span><span class="s7">).toAddress();</span></p>
<p class="p17"><span class="s14">      </span><span class="s7">//use address here</span><span class="s14">      <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">} </span><span class="s20"><b>catch</b></span><span class="s7"> (AddressStringException </span><span class="s19">e</span><span class="s7">) {</span></p>
<p class="p17"><span class="s14">      String msg = </span><span class="s19">e</span><span class="s14">.getMessage();</span><span class="s7">//detailed message indicating issue</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><b>Various Formats of MAC Addresses</b></span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7">MAC Addresses are expected to be in hexadecimal.  However, there are a wide variety of accepted formats for MAC addresses:</span></p>
<p class="p37"><span class="s7">aa:bb:cc:dd:ee:ff</span></p>
<p class="p37"><span class="s7">aa-bb-cc-dd-ee-ff</span></p>
<p class="p37"><span class="s7">aa bb cc dd ee ff</span></p>
<p class="p37"><span class="s7">aabb.ccdd.eeff</span></p>
<p class="p37"><span class="s7">aabbccddeeff</span></p>
<p class="p37"><span class="s7">aabbcc-ddeeff</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7">For the non-segmented format (</span><span class="s9">aabbccddeeff</span><span class="s7">), all 12 digits are required to avoid ambiguity.  Additionally, MAC addresses can be either 48 or 64 bits, and so for each such format there is the 64-bit equivalent:</span></p>
<p class="p37"><span class="s7">aa:bb:cc:dd:ee:ff:11:22</span></p>
<p class="p37"><span class="s7">aa-bb-cc-dd-ee-ff-11-22</span></p>
<p class="p37"><span class="s7">aa bb cc dd ee ff 11 22</span></p>
<p class="p37"><span class="s7">aabb.ccdd.eeff.1122</span></p>
<p class="p37"><span class="s7">aabbccddeeff1122</span></p>
<p class="p37"><span class="s7">aabbcc-ddeeff1122</span></p>
<p class="p37"><span class="s7"> </span></p>
<p class="p8"><span class="s7">For the non-segmented 64-bit format (</span><span class="s9">aabbccddeeff1122</span><span class="s7">), all 16 digits are required to avoid ambiguity.</span></p>
<p class="p37"><span class="s7"> </span></p>
<p class="p8"><span class="s7">As with IP addresses, you can specify ranges using </span><span class="s9">‘*’</span><span class="s7"> and </span><span class="s9">‘-’</span><span class="s7"> like</span><span class="s9"> aa-bb:*:*:cc:dd:ee. </span><span class="s7">The range character for addresses that use the dash </span><span class="s9">‘-’</span><span class="s7"> character as a separator is</span><span class="s9"> ‘|’, </span><span class="s7">like</span><span class="s9"> aa|bb-*-*-cc-dd-ee.</span></p>
<p class="p37"><span class="s7"> </span></p>
<p class="p18"><span class="s7"><b>Format Examples</b></span></p>
<p class="p18"><span class="s7"><b> </b></span></p>
<p class="p18"><span class="s7">For instance, the address 0a:0b:0c:0d:0e:0f can be represented many ways:</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p16"><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> parseMAC(String </span><span class="s19">formats</span><span class="s7">[]) {</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>for</b></span><span class="s7">(String </span><span class="s19">format</span><span class="s7"> : </span><span class="s19">formats</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s20"><b>new</b></span><span class="s7"> MACAddressString(</span><span class="s19">format</span><span class="s7">).getAddress());</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p16"><span class="s7">     <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> </span><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> main(String[] </span><span class="s19">args</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">      String </span><span class="s19">formats</span><span class="s7">[] = {</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"a:b:c:d:e:f"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"0a:0b:0c:0d:0e:0f"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"a:b:c:d:e:f"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"0a-0b-0c-0d-0e-0f"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"0a0b0c-0d0e0f"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"0a0b.0c0d.0e0f"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"0a 0b 0c 0d 0e 0f"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"0a0b0c0d0e0f"</span></p>
<p class="p16"><span class="s7">      };</span></p>
<p class="p16"><span class="s7">      parseMAC(</span><span class="s19">formats</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Output:</span></p>
<p class="p5"><span class="s7"> </span></p>
<p class="p16"><span class="s7">0a:0b:0c:0d:0e:0f</span></p>
<p class="p16"><span class="s7">0a:0b:0c:0d:0e:0f</span></p>
<p class="p16"><span class="s7">0a:0b:0c:0d:0e:0f</span></p>
<p class="p16"><span class="s7">0a:0b:0c:0d:0e:0f</span></p>
<p class="p16"><span class="s7">0a:0b:0c:0d:0e:0f</span></p>
<p class="p16"><span class="s7">0a:0b:0c:0d:0e:0f</span></p>
<p class="p16"><span class="s7">0a:0b:0c:0d:0e:0f</span></p>
<p class="p16"><span class="s7">0a:0b:0c:0d:0e:0f</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Ranges can be specified in the same way as for IP addresses (‘-’ for a specific range or ‘*’ for full range segments).</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">For instance, the address range </span><span class="s9">ff:0f:aa-ff:00-ff:00-ff:00-ff</span><span class="s7"> can be represented many ways:</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p16"><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> parseMAC(String </span><span class="s19">formats</span><span class="s7">[]) {</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>for</b></span><span class="s7">(String </span><span class="s19">format</span><span class="s7"> : </span><span class="s19">formats</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s20"><b>new</b></span><span class="s7"> MACAddressString(</span><span class="s19">format</span><span class="s7">).getAddress());</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p16"><span class="s7">     <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> </span><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> main(String[] </span><span class="s19">args</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">      String </span><span class="s19">formats</span><span class="s7">[] = {</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"ff:f:aa-ff:00-ff:00-ff:00-ff"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"ff:f:aa-ff:*:*:*"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"ff:0f:aa-ff:*:*:*"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"ff-0f-aa|ff-*-*-*"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"ff0faa|ff0fff-*"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"ff0f.aa00-ffff.*"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"ff 0f aa-ff * * *"</span><span class="s14">,</span></p>
<p class="p20"><span class="s14">            </span><span class="s7">"ff0faa000000-ff0fffffffff"</span><span class="s14">    <span class="Apple-converted-space"> </span></span></p>
<p class="p21"><span class="s7">};</span></p>
<p class="p16"><span class="s7">      parseMAC(</span><span class="s19">formats</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Output:</span></p>
<p class="p16"><span class="s7">ff:0f:aa-ff:*:*:*</span></p>
<p class="p16"><span class="s7">ff:0f:aa-ff:*:*:*</span></p>
<p class="p16"><span class="s7">ff:0f:aa-ff:*:*:*</span></p>
<p class="p16"><span class="s7">ff:0f:aa-ff:*:*:*</span></p>
<p class="p16"><span class="s7">ff:0f:aa-ff:*:*:*</span></p>
<p class="p16"><span class="s7">ff:0f:aa-ff:*:*:*</span></p>
<p class="p16"><span class="s7">ff:0f:aa-ff:*:*:*<br>
ff:0f:aa-ff:*:*:*</span></p>
<p class="p18"><span class="s7"><b> </b></span></p>
<p class="p18"><span class="s7"><b>Delimited Segments</b></span></p>
<p class="p18"><span class="s7"><b> </b></span></p>
<p class="p18"><span class="s7">The range formats allow you to specify ranges of values.  However, if you wish to parse addresses in which values are delimited, then you can use the methods </span><span class="s9">parseDelimitedSegments(String)</span><span class="s7"> and </span><span class="s9">countDelimitedAddresses(String)</span><span class="s7"> in </span><span class="s9">MACAddressString</span><span class="s7">. </span><span class="s9">parseDelimitedSegments</span><span class="s7"> will provide an iterator to traverse through the individual addresses.</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">For example, given "1,2:3:4,5:6:7:8", </span><span class="s9">countDelimitedAddresses</span><span class="s7"> will return 4 for the possible combinations: "1:3:4:6:7:8", "1:3:5:6:7:8", "2:3:4:6:7:8" and "2:3:5:6:7:8".  With each string obtained from </span><span class="s9">parseDelimitedSegments</span><span class="s7"> you can construct a </span><span class="s9">MACAddressString</span><span class="s7"> instance.</span></p>
<p class="p37"><span class="s7"> </span></p>
<p class="p18"><span class="s7"><b>MAC Address Validation Options</b></span></p>
<p class="p18"><span class="s7"><b> </b></span></p>
<p class="p18"><span class="s7">Validation options allow you to restrict the allowed formats.</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">You have the class </span><span class="s9">MACAddressStringParameters</span><span class="s7"> which can be passed into </span><span class="s9">MACAddressString</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">You constrict validation options using the appropriate builder classes that are nested classes in the options classes.  Here is an example:</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p16"><span class="s7">MACAddressStringParameters </span><span class="s22"><b>MAC_ADDRESS_OPTIONS_EXAMPLE</b></span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> MACAddressStringParameters.Builder().</span></p>
<p class="p21"><span class="s7">      allowEmpty(</span><span class="s20"><b>false</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">            allowAll(</span><span class="s20"><b>false</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">            getFormatBuilder().</span></p>
<p class="p16"><span class="s7">                  setRangeOptions(RangeParameters.</span><span class="s22">NO_RANGE</span><span class="s7">).</span></p>
<p class="p16"><span class="s7">                  allowLeadingZeros(</span><span class="s20"><b>true</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">                  allowUnlimitedLeadingZeros(</span><span class="s20"><b>false</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">                  allowWildcardedSeparator(</span><span class="s20"><b>false</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">                  allowShortSegments(</span><span class="s20"><b>true</b></span><span class="s7">).</span></p>
<p class="p16"><span class="s7">            getParentBuilder().</span></p>
<p class="p16"><span class="s7">            toParams();</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">The default options used by the library are permissive and not restrictive.</span></p>
<p class="p37"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><b>MAC Address Prefix Lengths</b></span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7">Prefix length in this library is defined general as the bit-length of the portion of the address that is not specific to an individual address but common amongst a group of addresses.  For IP addresses, this is explicitly defined as part of the address using the ‘/’ character.  For IP addresses, the prefix is potentially variable and depends on how subnets have been allocated.</span></p>
<p class="p8"><span class="s7">MAC Addresses don’t have the exact same concept of prefix length as IP addresses.  But concept of prefix can be applied in a more implicit sense.  For instance, a MAC address is typically divided into an OUI (Organizationally Unique Identifier) and ODI (Organizational Defined Identifier), so you might consider the OUI bits as the prefix.  There are other ways of assigning MAC address blocks as well, such as IAB (individual address block), or MA-S/MA-M/MA-L (MAC Address block small, medium, and large), in which a certain number of higher bits are provided as an identifier to organizations from which they can create various extended identifiers using the lower bits.  There is generally a pre-defined set of high bits that can be considered a prefix. This prefix is not variable and was typically assigned by the IEEE. However, there is no explicit way to represent a MAC address with an associated prefix, so the prefix is implicit to the address when it is created.</span></p>
<p class="p8"><span class="s7">Within this library, the prefix for a MAC address is defined as the largest number of high bits for which an address represents all addresses with the same set of higher bits.</span></p>
<p class="p8"><span class="s7">For instance, the prefix length of aa:*:*:*:*:* is 8 because the address represents all addresses that start with the same 8 bits "aa".  The prefix length of aa:*:cc:*:*:* is 24 because the address represents all addresses that start with the same 16 bits aa:*:cc.  The address aa:bb:cc:dd:ee:ff does not have a prefix or prefix length as it represents just a single address.</span></p>
<p class="p8"><span class="s7">Once a MAC address as an associated prefix length, that prefix length remains the same when any operations are applied to the address.</span></p>
<p class="p8"><span class="s7">In summary, on the MAC side, the prefix length is implicit and based upon the address, while on the IP address side, the prefix length is explicitly defined.</span></p>
<p class="p8"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #b40004; -webkit-text-stroke: #b40004"><span class="s7">MAC Address Operations</span></h2>
<p class="p30"><span class="s7">Many of the same address operations available for IP addresses are available for MAC addresses, including the prefix operations (although prefixes have somewhat different meaning for MAC as described in the previous section of this document), the section and segment access methods, iterators, containment, and reversal of bits, bytes and segments. <span class="Apple-converted-space"> </span></span></p>
<p class="p30"><span class="s7">The reverse operations are useful for for "MSB format", "IBM format", "Token-Ring format", and "non-canonical form", where the bits are reversed in each byte of a MAC address. <span class="Apple-converted-space"> </span></span></p>
<p class="p30"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #1a1a1a; -webkit-text-stroke: #1a1a1a"><span class="s7">IPv6 – MAC Address Integration</span></h2>
<p class="p8"><span class="s7">There is a standardized procedure for converting MAC addresses to IPv6 given a IPv6 64 bit prefix, as described in <a href="https://tools.ietf.org/html/rfc2464"><span class="s32">IETF RFC 2464</span></a>, <a href="https://tools.ietf.org/html/rfc3513"><span class="s32">RFC 3513</span></a>, and <a href="https://tools.ietf.org/html/rfc4944"><span class="s32">RFC 4944</span></a>.</span></p>
<p class="p8"><span class="s7">It details how to combine a 48 bit MAC address with a 64 bit IPv6 network prefix to produce a 128 bit IPv6 address. This is done by first constructing a 64-bit extended unique IPv6 interface identifier (EUI-64) from the MAC address. This library has implemented the same MAC / IPv6 integration in multiple ways.</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7">Starting with a MAC address or section and with the IPv6 prefix, you can construct an IPv6 address.</span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> IPv6Address(IPv6Address </span><span class="s19">prefix</span><span class="s7">, MACAddress </span><span class="s19">eui</span><span class="s7">)</span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> IPv6Address(IPv6AddressSection </span><span class="s19">section</span><span class="s7">, MACAddress </span><span class="s19">eui</span><span class="s7">)</span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> IPv6Address(IPv6AddressSection </span><span class="s19">section</span><span class="s7">, MACAddressSection </span><span class="s19">eui</span><span class="s7">)</span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> IPv6Address(IPv6AddressSection </span><span class="s19">section</span><span class="s7">, MACAddressSection </span><span class="s19">eui</span><span class="s7">, CharSequence </span><span class="s19">zone</span><span class="s7">)</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p8"><span class="s7">There are equivalent methods in the class </span><span class="s9">MACAddress</span><span class="s7"> for producing the link local address which has a pre-defined prefix, or for producing the host (interface identifier) address section of an IPv6 address.</span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> IPv6Address toLinkLocalIPv6()<br>
</span><span class="s20"><b>public</b></span><span class="s7"> IPv6AddressSection toEUI64IPv6()</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7">There is a similar method in MACAddressSection<span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> IPv6AddressSection toEUI64IPv6()</span></p>
<p class="p16"><span class="s7">     <span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s7">A MAC address is either 48 or 64 bits.  To be converted to IPv6, the 48 bit address has segments inserted (two 1 byte MAC segments with value 0xfffe) to extend the address to 64 bits.  For a 64 bit MAC address to be convertible, those same two segments must match the expected value of 0xffe.  The following methods in </span><span class="s9">MACAddress</span><span class="s7"> check will 64 bit addresses to ensure that are compatible with IPv6 by checking that the value of those two segments matches 0xfffe.  Note that the </span><span class="s9">asMAC</span><span class="s7"> argument allows you to extend using 0xffff rather than 0xfffe which is another manner by which a 48 bit MAC address can be extended to 64 bits.  However, for purposes of extending to an IPv6 address the argument should be </span><span class="s9">false</span><span class="s7"> so that the EUI-64 format is used.</span></p>
<p class="p15"><span class="s20"><b>public</b></span><span class="s7"> </span><span class="s20"><b>boolean</b></span><span class="s7"> isEUI64(</span><span class="s20"><b>boolean</b></span><span class="s7"> </span><span class="s19">asMAC</span><span class="s7">)<br>
</span><span class="s20"><b>public</b></span><span class="s7"> MACAddress toEUI64(</span><span class="s20"><b>boolean</b></span><span class="s7"> </span><span class="s19">asMAC</span><span class="s7">)</span></p>
<p class="p15"><span class="s7"> </span></p>
<p class="p8"><span class="s7">There are similar methods in </span><span class="s9">MACAddressSection</span></p>
<p class="p19"><span class="s7"><b>public</b></span><span class="s14"> </span><span class="s7"><b>boolean</b></span><span class="s14"> isEUI64(</span><span class="s7"><b>boolean</b></span><span class="s14"> </span><span class="s19">asMAC</span><span class="s14">)</span></p>
<p class="p19"><span class="s7"><b>public</b></span><span class="s14"> </span><span class="s7"><b>boolean</b></span><span class="s14"> isEUI64(</span><span class="s7"><b>boolean</b></span><span class="s14"> </span><span class="s19">asMAC</span><span class="s14">, </span><span class="s7"><b>boolean</b></span><span class="s14"> </span><span class="s19">partial</span><span class="s14">)</span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> MACAddressSection toEUI64(</span><span class="s20"><b>boolean</b></span><span class="s7"> </span><span class="s19">asMAC</span><span class="s7">)</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7">Given an existing EUI-64 section you can use the prepend and append methods to create a full IPv6 address section containing all segments:</span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> IPv6AddressSection prepend(IPv6AddressSection </span><span class="s19">other</span><span class="s7">)</span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> IPv6AddressSection append(IPv6AddressSection </span><span class="s19">other</span><span class="s7">)</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7">and from there you just construct the address:</span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> IPv6Address(IPv6AddressSection </span><span class="s19">section</span><span class="s7">)</span></p>
<p class="p15"><span class="s7">     <span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s7">To go the reverse direction IPv6 to MAC, there is a method in </span><span class="s9">IPv6Address </span><span class="s7">to produce a MAC address:</span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> MACAddress toEUI(</span><span class="s20"><b>boolean</b></span><span class="s7"> </span><span class="s19">extended</span><span class="s7">)</span></p>
<p class="p8"><span class="s7">and another in </span><span class="s9">IPv6AddressSection</span><span class="s7"> that uses whatever part of the interface identifier is included in the section to produce a MAC address section: <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> MACAddressSection toEUI(</span><span class="s20"><b>boolean</b></span><span class="s7"> </span><span class="s19">extended</span><span class="s7">)</span></p>
<p class="p8"><span class="s7">For instance, if the IPV6 address section is the 8 bytes corresponding to the network prefix of an IPV6 address section, then the resulting MAC address section will be 0 bytes.  If the IPV6 address section is the 8 bytes corresponding to the interface identifier, and that identifier has the required 0xfffe values in the 5th and 6th bytes, then the MAC address section will be the full 8 bytes of an EUI-64 MAC address.</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7">The following code is an example of constructing IPv6 addresses from a MAC address:</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> </span><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> main(String </span><span class="s19">args</span><span class="s7">[]) {</span></p>
<p class="p16"><span class="s7">      MACAddressString </span><span class="s19">macStr</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> MACAddressString(</span><span class="s21">"aa:bb:cc:dd:ee:ff"</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      MACAddress </span><span class="s19">macAddress</span><span class="s7"> = </span><span class="s19">macStr</span><span class="s7">.getAddress();</span></p>
<p class="p16"><span class="s7">      IPv6Address </span><span class="s19">linkLocal</span><span class="s7"> = </span><span class="s19">macAddress</span><span class="s7">.toLinkLocalIPv6();</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">linkLocal</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">      IPAddressString </span><span class="s19">ipv6Str</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"1111:2222:3333:4444::/64"</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      IPv6Address </span><span class="s19">ipv6Address</span><span class="s7"> = </span><span class="s19">ipv6Str</span><span class="s7">.getAddress().toIPv6();</span></p>
<p class="p16"><span class="s7">      IPv6Address </span><span class="s19">macIpv6</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPv6Address(</span><span class="s19">ipv6Address</span><span class="s7">, </span><span class="s19">macAddress</span><span class="s7">);</span></p>
<p class="p24"><span class="s7">System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">macIpv6</span><span class="s7">);</span></p>
<p class="p15"><span class="s7">}</span></p>
<p class="p15"><span class="s7"> </span></p>
<p class="p8"><span class="s7">Output:</span></p>
<p class="p16"><span class="s7">fe80::a8bb:ccff:fedd:eeff<br>
1111:2222:3333:4444:a8bb:ccff:fedd:eeff/64</span></p>
<p class="p8"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #b40004; -webkit-text-stroke: #b40004"><span class="s7">Address Framework</span></h2>
<p class="p8"><span class="s7">Much like there is a Java collections framework, there is an address framework to the IPAddress library.   It is a unified set of inter-related interfaces, abstract implementations, and algorithms for all addresses and address components.  It allows you to manipulate these items independently of implementation details, and provides standard interfaces to addresses and address components for code reuse and polymorphism.  It represents the common structure of addresses, sections, segments, and so on.</span></p>
<p class="p8"><span class="s7">You might wish to manipulate address components of different shapes and sizes transparently, or you may wish to manipulate different types of addresses or different address versions transparently.  One element of the interface is the ability to convert any address component to bytes, whether division, segment, section, or address.</span></p>
<p class="p8"><span class="s7">There is a hierarchy for the standard Address and Address Component data structures, which are addresses, sections of addresses, and segments of equal byte size inside those address sections.</span></p>
<p class="p14"><span class="s7"><img src="file:///image001.jpg" alt="image001.jpg"></span></p>
<p class="p14"><span class="s7"><img src="file:///image002.jpg" alt="image002.jpg"></span></p>
<p class="p14"><span class="s7"> </span></p>
<p class="p8"><span class="s7">There is a more diversified hierarchy for non-standard address structures, in which addresses or address sections might be divided into divisions of unequal length, or of non-integral bytesize.</span></p>
<p class="p14"><span class="s7"><img src="file:///image003.jpg" alt="image003.jpg"></span></p>
<p class="p8"><span class="s7">The address hierarchy of interfaces (purple) and classes (green) is shown:</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><img src="file:///image004.jpg" alt="image004.jpg"></span></p>
<p class="p8"><span class="s7">The full class hierarchy showing addresses, sections, division groupings, segments and divisions is shown here, separated into the three primary categories shown above.  The dashed lines indicate there are a few less-prominent classes in the library not shown in the diagram.</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7"><img src="file:///image005.jpg" alt="image005.jpg"></span></p>
<p class="p8"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #b40004; -webkit-text-stroke: #b40004"><span class="s7">Conversion to String Representation of Address</span></h2>
<p class="p8"><span class="s7">Here is a list of string methods, in no specific order. <span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s7">Note that, for a given address, the string produced by one of these methods might match those of other methods.  They are not necessarily distinct from each other for all addresses.</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7">All address types, HostName and IPAddressString:</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>toNormalizedString</b></span><span class="s7">: Produces a consistent string.  For addresses, a string that is somewhat similar and consistent for all address components of the same type.  Uses no segment compression in IPv6.  Uses xx:xx:xx:xx:xx:xx for MAC address.  Prints HostName instances in standard formats as expected by URLs and as dictated by RFCs, including port or service name and using square brackets for IPV6 addresses.  Prints a standardized format for IPAddressString instances that cannot be converted to addresses (such as ‘*’). For HostName and IPAddressString instances constructed from invalid strings, prints the original string used to construct.</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>toString</b></span><span class="s7">: same as </span><span class="s9"><b>toCanonicalString </b></span><span class="s7">for addresses.  For HostName and IPAddressString instances, prints the original string used to construct.<br>
<br>
</span></p>
<p class="p8"><span class="s7">All address types:</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>toCanonicalString</b></span><span class="s7">: the string recommended by one or more RFCs or other common standard.</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>toCompressedString</b></span><span class="s7">: a short representation of the address while remaining within the confines of standard representation(s) of the address.  For IPv6 compresses all compressible segments.</span></p>
<p class="p46"><span class="s15">·</span><span class="s16">      </span><span class="s7"><b>toHexString</b></span><span class="s12">: base 64<br>
<br>
</span></p>
<p class="p8"><span class="s7">IP addresses and HostName:</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>toNormalizedWildcardString</b></span><span class="s7">: similar to </span><span class="s9"><b>toNormalizedString</b></span><span class="s7">, but uses wildcards and does not print prefix length for addresses that have prefix lengths</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7">IP addresses only:</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>toFullString</b></span><span class="s7">: a string which maintains a common length</span><span class="s18">, </span><span class="s7">a string with no compressed segments and all segments of full length, which is 4 characters for IPv6 segments and 3 characters for IPv4 segments</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>toCanonicalWildcardString</b></span><span class="s7">: similar to </span><span class="s9"><b>toCanonicalString</b></span><span class="s7">, but uses wildcards and does not print prefix length for addresses that have prefix lengths</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>toCompressedWildcardString</b></span><span class="s7">: similar to </span><span class="s9"><b>toCompressedString</b></span><span class="s7">, but uses wildcards and does not print prefix length for addresses that have prefix lengths</span><span class="s9"><b><span class="Apple-converted-space"> </span></b></span></p>
<p class="p46"><span class="s15">·</span><span class="s16">      </span><span class="s7"><b>toSQLWildcardString</b></span><span class="s12">: similar to </span><span class="s7"><b>toNormalizedWildcardString</b></span><span class="s12">, but uses SQL wildcards</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>toPrefixLengthString</b></span><span class="s7">: a string with CIDR prefix length if it has one, and compresses the host for IPv6.  For IPv4 it is the same as </span><span class="s9"><b>toCanonicalString</b></span><span class="s7">.<span class="Apple-converted-space"> </span></span></p>
<p class="p46"><span class="s15">·</span><span class="s16">      </span><span class="s7"><b>toSubnetString</b></span><span class="s12">: uses </span><span class="s7"><b>toNormalizedWildcardString </b></span><span class="s12">for IPv4 and </span><span class="s7"><b>toPrefixLengthString</b></span><span class="s12"> for IPv6</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>toReverseDNSLookupString</b></span><span class="s7">: a string for reverse DNS lookup</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>toOctalString</b></span><span class="s7">: base 8, optionally with a ‘0’ prefix to indicate octal</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>toBinaryString</b></span><span class="s7">: all ones and zeros</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>toConvertedString</b></span><span class="s18">: </span><span class="s7">if an IPv6 address can be converted to IPv4 as determined by </span><span class="s9">isIPv4Convertible()</span><span class="s7">, produces the result of </span><span class="s9"><b>toMixedString</b></span><span class="s7">.  For IPv4 same as </span><span class="s9"><b>toCanonicalString</b></span><span class="s7">.</span></p>
<p class="p9"><span class="s11">·</span><span class="s10">      </span><span class="s26"><b>toUNCHostName</b></span><span class="s13">: </span><span class="s7">Microsoft UNC path component</span></p>
<p class="p46"><span class="s15">·</span><span class="s16">      </span><span class="s7"><b>toNormalizedString(IPStringOptions)</b></span><span class="s12"> : your own customized string</span></p>
<p class="p13"><span class="s7"> </span></p>
<p class="p8"><span class="s7">IPv6 only:</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>toMixedString</b></span><span class="s7">: mixed IPv6/IPv4 string format like a:b:c:d:e:f:255.0.255.255</span></p>
<p class="p46"><span class="s15">·</span><span class="s16">      </span><span class="s7"><b>toBase85String</b></span><span class="s12">: RFC 1924</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7">MAC address only:</span></p>
<p class="p46"><span class="s15">·</span><span class="s16">      </span><span class="s7"><b>toColonDelimitedString</b></span><span class="s12">: same as </span><span class="s7"><b>toNormalizedString</b></span><span class="s12">, xx:xx:xx:xx:xx:xx</span></p>
<p class="p46"><span class="s15">·</span><span class="s16">      </span><span class="s7"><b>toDashedString</b></span><span class="s12">: same as </span><span class="s7"><b>toCanonicalString</b></span><span class="s12">, xx-xx-xx-xx-xx-xx</span></p>
<p class="p36"><span class="s15">·</span><span class="s16">      </span><span class="s9"><b>toDottedString</b></span><span class="s7">: xxxx.xxxx.xxxx</span></p>
<p class="p46"><span class="s15">·</span><span class="s16">      </span><span class="s7"><b>toSpaceDelimitedString</b></span><span class="s12">: xx xx xx xx xx xx<br>
<br>
</span></p>
<p class="p8"><span class="s7"><b> </b></span></p>
<p class="p8"><span class="s7"><b>More Details and Examples</b></span></p>
<p class="p8"><span class="s7">AddressSegmentSeries objects (such as Address and AddressSection) have methods that produce strings in various formats: </span><span class="s9">toCanonicalString</span><span class="s7">,</span><span class="s9"> toNormalizedString</span><span class="s7">,</span><span class="s9"> toCompressedString</span><span class="s7">, and</span><span class="s9"> toHexString</span><span class="s7">.<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p21"><span class="s20"><b>public</b></span><span class="s7"> </span><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> main(String[] </span><span class="s19">args</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">            printStrings(</span><span class="s20"><b>new</b></span><span class="s7"> MACAddressString(</span><span class="s21">"a:bb:c:dd:e:ff"</span><span class="s7">).getAddress());</span></p>
<p class="p16"><span class="s7">            printStrings(</span><span class="s20"><b>new</b></span><span class="s7"> MACAddressString(</span><span class="s21">"a:bb:c:*"</span><span class="s7">).getAddress());</span></p>
<p class="p16"><span class="s7">            printStrings(</span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"a:bb:c::/64"</span><span class="s7">).getAddress());</span></p>
<p class="p16"><span class="s7">            printStrings(</span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"1.2.3.4"</span><span class="s7">).getAddress());</span></p>
<p class="p16"><span class="s7">            printStrings(</span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"1.2.0.0/16"</span><span class="s7">).getAddress());</span></p>
<p class="p16"><span class="s7">            printStrings(</span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"a:bb:c::dd:e:ff"</span><span class="s7">).getAddress());</span></p>
<p class="p16"><span class="s7">      }    <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> printStrings(AddressSegmentSeries </span><span class="s19">series</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">series</span><span class="s7">.toCanonicalString());</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">series</span><span class="s7">.toNormalizedString());</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">series</span><span class="s7">.toCompressedString());</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">series</span><span class="s7">.toHexString(</span><span class="s20"><b>true</b></span><span class="s7">));</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.print(</span><span class="s21">"lower: "</span><span class="s7"> + </span><span class="s19">series</span><span class="s7">.getLower() + </span><span class="s21">" bytes:"</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(Arrays.toString(</span><span class="s19">series</span><span class="s7">.getBytes()));</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.print(</span><span class="s21">"upper: "</span><span class="s7"> + </span><span class="s19">series</span><span class="s7">.getUpper() + </span><span class="s21">" bytes:"</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(Arrays.toString(</span><span class="s19">series</span><span class="s7">.getUpperBytes()));</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println();</span></p>
<p class="p15"><span class="s7">      }</span></p>
<p class="p15"><span class="s7"> </span></p>
<p class="p8"><span class="s7">Output:</span></p>
<p class="p16"><span class="s7">0a-bb-0c-dd-0e-ff</span></p>
<p class="p16"><span class="s7">0a:bb:0c:dd:0e:ff</span></p>
<p class="p16"><span class="s7">a:bb:c:dd:e:ff</span></p>
<p class="p16"><span class="s7">0x0abb0cdd0eff</span></p>
<p class="p16"><span class="s7">lower: 0a:bb:0c:dd:0e:ff bytes:[10, -69, 12, -35, 14, -1]</span></p>
<p class="p16"><span class="s7">upper: 0a:bb:0c:dd:0e:ff bytes:[10, -69, 12, -35, 14, -1]</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">0a-bb-0c-*-*-*</span></p>
<p class="p16"><span class="s7">0a:bb:0c:*:*:*</span></p>
<p class="p16"><span class="s7">a:bb:c:*:*:*</span></p>
<p class="p16"><span class="s7">0x0abb0c000000-0x0abb0cffffff</span></p>
<p class="p16"><span class="s7">lower: 0a:bb:0c:00:00:00 bytes:[10, -69, 12, 0, 0, 0]</span></p>
<p class="p16"><span class="s7">upper: 0a:bb:0c:ff:ff:ff bytes:[10, -69, 12, -1, -1, -1]</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">a:bb:c::/64</span></p>
<p class="p16"><span class="s7">a:bb:c:0:0:0:0:0/64</span></p>
<p class="p16"><span class="s7">a:bb:c::/64</span></p>
<p class="p16"><span class="s7">0x000a00bb000c00000000000000000000-0x000a00bb000c0000ffffffffffffffff</span></p>
<p class="p16"><span class="s7">lower: a:bb:c:0:0:0:0:0 bytes:[0, 10, 0, -69, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></p>
<p class="p16"><span class="s7">upper: a:bb:c:0:ffff:ffff:ffff:ffff bytes:[0, 10, 0, -69, 0, 12, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1]</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">1.2.3.4</span></p>
<p class="p16"><span class="s7">1.2.3.4</span></p>
<p class="p16"><span class="s7">1.2.3.4</span></p>
<p class="p16"><span class="s7">0x01020304</span></p>
<p class="p16"><span class="s7">lower: 1.2.3.4 bytes:[1, 2, 3, 4]</span></p>
<p class="p16"><span class="s7">upper: 1.2.3.4 bytes:[1, 2, 3, 4]</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">1.2.0.0/16</span></p>
<p class="p16"><span class="s7">1.2.0.0/16</span></p>
<p class="p16"><span class="s7">1.2.0.0/16</span></p>
<p class="p16"><span class="s7">0x01020000-0x0102ffff</span></p>
<p class="p16"><span class="s7">lower: 1.2.0.0 bytes:[1, 2, 0, 0]</span></p>
<p class="p16"><span class="s7">upper: 1.2.255.255 bytes:[1, 2, -1, -1]</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">a:bb:c::dd:e:ff</span></p>
<p class="p16"><span class="s7">a:bb:c:0:0:dd:e:ff</span></p>
<p class="p16"><span class="s7">a:bb:c::dd:e:ff</span></p>
<p class="p16"><span class="s7">0x000a00bb000c0000000000dd000e00ff</span></p>
<p class="p16"><span class="s7">lower: a:bb:c:0:0:dd:e:ff bytes:[0, 10, 0, -69, 0, 12, 0, 0, 0, 0, 0, -35, 0, 14, 0, -1]<br>
upper: a:bb:c:0:0:dd:e:ff bytes:[0, 10, 0, -69, 0, 12, 0, 0, 0, 0, 0, -35, 0, 14, 0, -1]</span></p>
<p class="p15"><span class="s7"> </span></p>
<p class="p14"><span class="s7"> </span></p>
<p class="p8"><span class="s7">The </span><span class="s9">IPAddress</span><span class="s7"> and </span><span class="s9">IPAddressSection</span><span class="s7"> classes and their version-specific subclasses have additional methods to produce specific strings representing the address:</span></p>
<p class="p14"><span class="s7"> </span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> </span><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> main(String[] </span><span class="s19">args</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">address</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"a:b:c::e:f"</span><span class="s7">).getAddress();</span></p>
<p class="p16"><span class="s7">      print(</span><span class="s19">address</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      </span><span class="s19">address</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"a:b:c::"</span><span class="s7">).getAddress();</span></p>
<p class="p16"><span class="s7">      print(</span><span class="s19">address</span><span class="s7">);</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p39"><span class="s7">/a:b:c:*:: cannot be represented as a range of two single values</span></p>
<p class="p17"><span class="s14">      </span><span class="s7">//so this throws exception in toBase85String(), toBinaryString(), and toHexString()</span></p>
<p class="p16"><span class="s7">      </span><span class="s19">address</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"a:b:c:*::"</span><span class="s7">).getAddress();</span></p>
<p class="p16"><span class="s7">      print(</span><span class="s19">address</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> print(IPAddress </span><span class="s19">address</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toCanonicalString());</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toFullString());</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toNormalizedString());</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toSQLWildcardString());</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toSubnetString());</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>try</b></span><span class="s7"> {</span></p>
<p class="p16"><span class="s7">            </span><span class="s20"><b>if</b></span><span class="s7">(</span><span class="s19">address</span><span class="s7">.isIPv6()) {</span></p>
<p class="p16"><span class="s7">                  System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toIPv6().toMixedString());</span></p>
<p class="p16"><span class="s7">                  System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toIPv6().toBase85String());</span></p>
<p class="p16"><span class="s7">            }</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toBinaryString());</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toHexString(</span><span class="s20"><b>true</b></span><span class="s7">));</span></p>
<p class="p16"><span class="s7">      } </span><span class="s20"><b>catch</b></span><span class="s7">(IncompatibleAddressException </span><span class="s19">e</span><span class="s7">) {}</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println();</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p35"><span class="s7"> </span></p>
<p class="p8"><span class="s7">Output:</span></p>
<p class="p35"><span class="s7"> </span></p>
<p class="p16"><span class="s7">a:b:c::e:f</span></p>
<p class="p16"><span class="s7">000a:000b:000c:0000:0000:0000:000e:000f</span></p>
<p class="p16"><span class="s7">a:b:c:0:0:0:e:f</span></p>
<p class="p16"><span class="s7">a:b:c:0:0:0:e:f</span></p>
<p class="p16"><span class="s7">a:b:c::e:f</span></p>
<p class="p16"><span class="s7">a:b:c::0.14.0.15</span></p>
<p class="p16"><span class="s7">00|N0s0$N0-%*(tF74+!</span></p>
<p class="p16"><span class="s7">00000000000010100000000000001011000000000000110000000000000000000000000000000000000000000000000000000000000011100000000000001111</span></p>
<p class="p16"><span class="s7">0x000a000b000c000000000000000e000f</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">a:b:c::</span></p>
<p class="p16"><span class="s7">000a:000b:000c:0000:0000:0000:0000:0000</span></p>
<p class="p16"><span class="s7">a:b:c:0:0:0:0:0</span></p>
<p class="p16"><span class="s7">a:b:c:0:0:0:0:0</span></p>
<p class="p16"><span class="s7">a:b:c::</span></p>
<p class="p16"><span class="s7">a:b:c::</span></p>
<p class="p16"><span class="s7">00|N0s0$N0-%*(tF5l-X</span></p>
<p class="p16"><span class="s7">00000000000010100000000000001011000000000000110000000000000000000000000000000000000000000000000000000000000000000000000000000000</span></p>
<p class="p16"><span class="s7">0x000a000b000c00000000000000000000</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">a:b:c:*::</span></p>
<p class="p16"><span class="s7">000a:000b:000c:0000-ffff:0000:0000:0000:0000</span></p>
<p class="p16"><span class="s7">a:b:c:*:0:0:0:0</span></p>
<p class="p16"><span class="s7">a:b:c:%:0:0:0:0</span></p>
<p class="p16"><span class="s7">a:b:c:*::</span></p>
<p class="p16"><span class="s7">a:b:c:*::</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7"><b>UNC Strings</b></span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">The method </span><span class="s9">toUNCHostName() </span><span class="s7">produces the UNC IP-literal string.</span></p>
<p class="p21"><span class="s7">IPAddressString </span><span class="s19">ipAddressString</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"2001:db8::1"</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">address</span><span class="s7"> = </span><span class="s19">ipAddressString</span><span class="s7">.getAddress();</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toUNCHostName());</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">      </span><span class="s19">ipAddressString</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"1.2.3.4"</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      </span><span class="s19">address</span><span class="s7"> = </span><span class="s19">ipAddressString</span><span class="s7">.getAddress();</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toUNCHostName());</span></p>
<p class="p5"><span class="s7"> </span></p>
<p class="p8"><span class="s7">Output:</span></p>
<p class="p16"><span class="s7">2001-db8-0-0-0-0-0-1.ipv6-literal.net</span></p>
<p class="p16"><span class="s7">1.2.3.4</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7"><b>DNS Lookup Strings</b></span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">The methods </span><span class="s9">toReverseDNSLookupString() </span><span class="s7">will produce a string for DNS lookup.  If you wish to do a DNS lookup for a subnet rather than a full address, you can use </span><span class="s9">getNetworkSection()</span><span class="s7"> to provide the network section you wish to lookup.  You can specify the prefix length in either the string itself or the call to get the network section.</span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p21"><span class="s7">IPAddressString </span><span class="s19">ipAddressString</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"2001:db8::1"</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      IPAddress </span><span class="s19">address</span><span class="s7"> = </span><span class="s19">ipAddressString</span><span class="s7">.getAddress();</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toReverseDNSLookupString());</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">      IPAddressSection </span><span class="s19">addressSection</span><span class="s7"> = </span><span class="s19">address</span><span class="s7">.getNetworkSection(64);</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">addressSection</span><span class="s7">.toReverseDNSLookupString());</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p17"><span class="s14">      </span><span class="s7">//same with prefix</span></p>
<p class="p16"><span class="s7">      </span><span class="s19">ipAddressString</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"2001:db8::1/64"</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      </span><span class="s19">address</span><span class="s7"> = </span><span class="s19">ipAddressString</span><span class="s7">.getAddress();</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toReverseDNSLookupString());</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">      </span><span class="s19">addressSection</span><span class="s7"> = </span><span class="s19">address</span><span class="s7">.getNetworkSection();</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">addressSection</span><span class="s7">.toReverseDNSLookupString());</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p17"><span class="s14">      </span><span class="s7">//prefix block</span></p>
<p class="p16"><span class="s7">      </span><span class="s19">ipAddressString</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"2001:db8::/64"</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      </span><span class="s19">address</span><span class="s7"> = </span><span class="s19">ipAddressString</span><span class="s7">.getAddress();</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toReverseDNSLookupString());</span></p>
<p class="p16"><span class="s7">           <span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s7">      </span><span class="s19">addressSection</span><span class="s7"> = </span><span class="s19">address</span><span class="s7">.getNetworkSection();</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">addressSection</span><span class="s7">.toReverseDNSLookupString());</span><span class="s17"><span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p8"><span class="s7">Output:</span></p>
<p class="p16"><span class="s7">1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa</span></p>
<p class="p16"><span class="s7">0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa</span></p>
<p class="p16"><span class="s7">1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa</span></p>
<p class="p16"><span class="s7">0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa</span></p>
<p class="p16"><span class="s7">*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa</span></p>
<p class="p16"><span class="s7">0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa</span></p>
<p class="p18"><span class="s7"><b> </b></span></p>
<p class="p18"><span class="s7"><b> </b></span></p>
<p class="p18"><span class="s7"><b>General String Methods</b></span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">The methods </span><span class="s9">toCanonicalString</span><span class="s7"> and </span><span class="s9">toCompressedString</span><span class="s7"> are available for any address or address section. <span class="Apple-converted-space"> </span></span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">The methods </span><span class="s9">toHexString</span><span class="s7"> and </span><span class="s9">toNormalizedString</span><span class="s7"> are available for any address component, including segments and sections.</span></p>
<p class="p5"><span class="s7"> </span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7"><b>Prefix Length Indicator in Strings</b></span></p>
<p class="p18"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Typically prefix lengths will be added to IP strings.  To choose to print wildcards '*' and range characters '-' as opposed to using prefix length, there are additional methods:</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p15"><span class="s20"><b>public</b></span><span class="s7"> </span><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> main(String[] </span><span class="s19">args</span><span class="s7">) {<br>
      IPAddress </span><span class="s19">address</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"a:b:c::/64"</span><span class="s7">).getAddress();<br>
      print(</span><span class="s19">address</span><span class="s7">);<br>
      </span><span class="s19">address</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"a:b:c:*::/64"</span><span class="s7">).getAddress();<br>
      print(</span><span class="s19">address</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> print(IPAddress </span><span class="s19">address</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toCanonicalString());</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toCanonicalWildcardString());</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toFullString());</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toNormalizedString());</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.toSQLWildcardString());</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println();</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p16"><span class="s7"> </span></p>
<p class="p8"><span class="s7">Output:</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">a:b:c::/64</span></p>
<p class="p16"><span class="s7">a:b:c:0:*:*:*:*</span></p>
<p class="p16"><span class="s7">000a:000b:000c:0000:0000:0000:0000:0000/64</span></p>
<p class="p16"><span class="s7">a:b:c:0:0:0:0:0/64</span></p>
<p class="p16"><span class="s7">a:b:c:0:%:%:%:%</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">a:b:c:*::/64</span></p>
<p class="p16"><span class="s7">a:b:c:*:*:*:*:*</span></p>
<p class="p16"><span class="s7">000a:000b:000c:0000-ffff:0000:0000:0000:0000/64</span></p>
<p class="p16"><span class="s7">a:b:c:*:0:0:0:0/64</span></p>
<p class="p16"><span class="s7">a:b:c:%:%:%:%:%</span></p>
<p class="p5"><span class="s7"> </span></p>
<p class="p35"><span class="s7"> </span></p>
<p class="p18"><span class="s7"><b>IP Version-dependent Strings</b></span></p>
<p class="p8"><span class="s7">Some strings are version-dependent:</span></p>
<p class="p8"><span class="s7"> </span></p>
<p class="p15"><span class="s20"><b>public</b></span><span class="s7"> </span><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> main(String[] </span><span class="s19">args</span><span class="s7">) {</span></p>
<p class="p17"><span class="s14">      </span><span class="s7">//toSubnetString() prefers '*' for IPv4 and prefix for IPv6</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"1.2.0.0/16"</span><span class="s7">).getAddress().toSubnetString());</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"a:b::/64"</span><span class="s7">).getAddress().toSubnetString());</span></p>
<p class="p16"><span class="s7">     <span class="Apple-converted-space"> </span></span></p>
<p class="p17"><span class="s14">      </span><span class="s7">//converts IPv4-mapped to a:b:c:d:e:f:1.2.3.4 notation</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"::ffff:a:b"</span><span class="s7">).getAddress().toConvertedString());</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Output:</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">1.2.*.*</span></p>
<p class="p16"><span class="s7">a:b::/64</span></p>
<p class="p16"><span class="s7">::ffff:0.10.0.11</span></p>
<p class="p35"><span class="s7"> </span></p>
<p class="p35"><span class="s7"> </span></p>
<p class="p18"><span class="s7"><b>Collections of IP Address Strings</b></span></p>
<p class="p18"><span class="s7"><br>
Alternatively, you can produce collections of strings:</span></p>
<p class="p35"><span class="s7"> </span></p>
<p class="p15"><span class="s20"><b>public</b></span><span class="s7"> </span><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> main(String[] </span><span class="s19">args</span><span class="s7">) {<br>
      IPAddress </span><span class="s19">address</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"a:b:c::e:f"</span><span class="s7">).getAddress();<br>
      print(</span><span class="s19">address</span><span class="s7">);<br>
}</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s20"><b>private</b></span><span class="s7"> </span><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> print(IPAddress </span><span class="s19">address</span><span class="s7">) {</span></p>
<p class="p17"><span class="s14">      </span><span class="s7">//print(address.toAllStrings()); produces many strings</span></p>
<p class="p16"><span class="s7">      print(</span><span class="s19">address</span><span class="s7">.toStandardStrings());</span></p>
<p class="p16"><span class="s7">      print(</span><span class="s20"><b>new</b></span><span class="s7"> String[] {</span><span class="s21">""</span><span class="s7">});</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s20"><b>public</b></span><span class="s7"> </span><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> print(String </span><span class="s19">strings</span><span class="s7">[]) {</span></p>
<p class="p16"><span class="s7">      </span><span class="s20"><b>for</b></span><span class="s7">(String </span><span class="s19">str</span><span class="s7"> : </span><span class="s19">strings</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">            System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">str</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">      }</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p18"><span class="s7"><br>
Output:</span></p>
<p class="p35"><span class="s7"> </span></p>
<p class="p16"><span class="s7">a:b:c:0:0:0:0.14.0.15</span></p>
<p class="p16"><span class="s7">a:b:c:0:0:0:000.014.000.015</span></p>
<p class="p16"><span class="s7">000a:000b:000c:0000:0000:0000:0.14.0.15</span></p>
<p class="p16"><span class="s7">000a:000b:000c:0000:0000:0000:000.014.000.015</span></p>
<p class="p16"><span class="s7">A:B:C:0:0:0:0.14.0.15</span></p>
<p class="p16"><span class="s7">A:B:C:0:0:0:000.014.000.015</span></p>
<p class="p16"><span class="s7">000A:000B:000C:0000:0000:0000:0.14.0.15</span></p>
<p class="p16"><span class="s7">000A:000B:000C:0000:0000:0000:000.014.000.015<br>
a:b:c::0.14.0.15</span></p>
<p class="p16"><span class="s7">a:b:c::000.014.000.015</span></p>
<p class="p16"><span class="s7">000a:000b:000c::0.14.0.15</span></p>
<p class="p16"><span class="s7">000a:000b:000c::000.014.000.015</span></p>
<p class="p16"><span class="s7">A:B:C::0.14.0.15</span></p>
<p class="p16"><span class="s7">A:B:C::000.014.000.015</span></p>
<p class="p16"><span class="s7">000A:000B:000C::0.14.0.15</span></p>
<p class="p16"><span class="s7">000A:000B:000C::000.014.000.015</span></p>
<p class="p16"><span class="s7">a:b:c:0:0:0:e:f</span></p>
<p class="p16"><span class="s7">000a:000b:000c:0000:0000:0000:000e:000f</span></p>
<p class="p16"><span class="s7">A:B:C:0:0:0:E:F</span></p>
<p class="p16"><span class="s7">000A:000B:000C:0000:0000:0000:000E:000F</span></p>
<p class="p16"><span class="s7">a:b:c::e:f</span></p>
<p class="p16"><span class="s7">000a:000b:000c::000e:000f</span></p>
<p class="p16"><span class="s7">A:B:C::E:F</span></p>
<p class="p16"><span class="s7">000A:000B:000C::000E:000F</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p18"><span class="s7">The String collections can be customized with</span><span class="s33"> </span><span class="s26">toNormalizedString(StringOptions </span><span class="s34">params</span><span class="s26">)</span></p>
<p class="p8"><span class="s7">Note that string collections never have duplicate strings.  The String collections can be customized with</span><span class="s33"> </span><span class="s26">toStrings(IPStringBuilderOptions </span><span class="s34">options</span><span class="s26">).</span></p>
<p class="p14"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #b40004; -webkit-text-stroke: #b40004"><span class="s7">Searching Text of Databases for all Addresses in a Subnet</span></h2>
<p class="p8"><span class="s7">Suppose you wanted to search for all addresses from a subnet in a large amount of text data.  For instance, suppose you wanted to search for all addresses in the text from the subnet a:b:0:0::/64.  You can start a representation of just the network prefix section of the address, then you can get all such strings for that prefix.</span></p>
<p class="p16"><span class="s7">IPAddressSection </span><span class="s19">prefix</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"a:b::"</span><span class="s7">).getAddress().</span></p>
<p class="p16"><span class="s7">      getNetworkSection(64, </span><span class="s20"><b>false</b></span><span class="s7">);</span></p>
<p class="p16"><span class="s7">String </span><span class="s19">strings</span><span class="s7">[] = </span><span class="s19">prefix</span><span class="s7">.toStandardStringCollection().toStrings();</span></p>
<p class="p16"><span class="s20"><b>for</b></span><span class="s7">(String </span><span class="s19">str</span><span class="s7"> : </span><span class="s19">strings</span><span class="s7">) {</span></p>
<p class="p16"><span class="s7">      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">str</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p5"><span class="s7"> </span></p>
<p class="p8"><span class="s7">Output:</span></p>
<p class="p15"><span class="s7">a:b:0:0<br>
000a:000b:0000:0000<br>
A:B:0:0<br>
000A:000B:0000:0000<br>
a:b::<br>
000a:000b::<br>
A:B::<br>
000A:000B::</span></p>
<p class="p5"><span class="s7"> </span></p>
<p class="p8"><span class="s7">If you need to be more stringent or less stringent about the address formats you wish to search, then you can use</span><span class="s35"> </span><span class="s26">toStringCollection(IPStringBuilderOptions </span><span class="s34">options</span><span class="s26">)</span><span class="s23"> </span><span class="s7">with an instance of</span><span class="s33"> </span><span class="s26">IPv6StringBuilderOptions</span><span class="s33">.</span></p>
<p class="p8"><span class="s7">Searching for those strings will find the subnet addresses.  However, you may get a few false positives, like "a:b::d:e:f:a:b".  To eliminate the false positives, you can just emulate in Java the SQL code produced below for the SQL database search, using substrings constructed from the segment separators.</span></p>
<p class="p8"><span class="s7">For a MySQL database search:</span></p>
<p class="p15"><span class="s20"><b>public</b></span><span class="s7"> </span><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> main(String[] </span><span class="s19">args</span><span class="s7">) {</span></p>
<p class="p15"><span class="s7">      IPAddressSection </span><span class="s19">prefix</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"a:b::"</span><span class="s7">).<br>
            getAddress().getNetworkSection(64, </span><span class="s20"><b>false</b></span><span class="s7">);<br>
      StringBuilder </span><span class="s19">sql</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> StringBuilder(</span><span class="s21">"Select rows from table where "</span><span class="s7">);<br>
      </span><span class="s19">prefix</span><span class="s7">.getStartsWithSQLClause(</span><span class="s19">sql</span><span class="s7">, </span><span class="s21">"column1"</span><span class="s7">);<br>
      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">sql</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p8"><span class="s7">Output:</span></p>
<p class="p15"><span class="s7">Select rows from table where ((substring_index(column1,':',4) = 'a:b:0:0') OR ((substring_index(column1,':',3) = 'a:b:') AND (LENGTH (column1) - LENGTH(REPLACE(column1, ':', '')) &lt;= 6)))</span></p>
<p class="p15"><span class="s7"> </span></p>
<p class="p8"><span class="s7">For IPv4, another way to search for a subnet like 1.2.0.0/16 would be to do a SELECT with the following string</span></p>
<p class="p15"><span class="s20"><b>public</b></span><span class="s7"> </span><span class="s20"><b>static</b></span><span class="s7"> </span><span class="s20"><b>void</b></span><span class="s7"> main(String[] </span><span class="s19">args</span><span class="s7">) {<br>
      String </span><span class="s19">wildcardString</span><span class="s7"> = </span><span class="s20"><b>new </b></span><span class="s7">IPAddressString(</span><span class="s21">"1.2.0.0/16"</span><span class="s7">).<br>
            getAddress().toSQLWildcardString();<br>
      System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">wildcardString</span><span class="s7">);</span></p>
<p class="p16"><span class="s7">}</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Output:</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p16"><span class="s7">1.2.%.%</span></p>
<p class="p26"><span class="s7"> </span></p>
<p class="p18"><span class="s7">Then your SQL search string would be like:</span></p>
<p class="p47"><span class="s7">Select rows from table where column1 like </span><span class="s14">1.2.%.%</span></p>
<p class="p15"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #b40004; -webkit-text-stroke: #b40004"><span class="s7">Containment and Subnet Membership</span></h2>
<p class="p8"><span class="s7">To check whether an IP address is contained by a subnet:</span></p>
<p class="p15"><span class="s7">IPAddress </span><span class="s19">address</span><span class="s7"> = </span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"1.2.0.0/16"</span><span class="s7">).getAddress();<br>
System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.contains(</span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"1.2.3.4"</span><span class="s7">).getAddress()));<br>
System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.contains(</span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"1.2.3.0/24"</span><span class="s7">).getAddress()));<br>
System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.contains(</span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"1.2.3.0/25"</span><span class="s7">).getAddress()));<br>
System.</span><span class="s22"><b>out</b></span><span class="s7">.println(</span><span class="s19">address</span><span class="s7">.contains(</span><span class="s20"><b>new</b></span><span class="s7"> IPAddressString(</span><span class="s21">"1.1.0.0"</span><span class="s7">).getAddress()));</span></p>
<p class="p5"><span class="s7"> </span></p>
<p class="p8"><span class="s7">Output:</span></p>
<p class="p15"><span class="s7">true<br>
true<br>
true<br>
false</span></p>
<p class="p5"><span class="s7"> </span></p>
<p class="p18"><span class="s7">The contains method is not restricted to IP addresses or IP address prefixed addresses.  There is a </span><span class="s9">contains</span><span class="s7"> method for every </span><span class="s9">Address</span><span class="s7"> or </span><span class="s9">AddressSection</span><span class="s7">.</span></p>
<p class="p5"><span class="s7"> </span></p>
<p class="p18"><span class="s7">There is also an assortment of iterators for addresses, sections, and segments which represent multiple values.  There is an </span><span class="s9">iterator()</span><span class="s7">, </span><span class="s9">getLower()</span><span class="s7"> method and </span><span class="s9">getUpper()</span><span class="s7"> method for every address component.</span></p>
<p class="p18"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #b40004; -webkit-text-stroke: #b40004"><span class="s7">DNS Resolution and URLs</span></h2>
<p class="p8"><span class="s7">If you have a string that can be a host or an address and you wish to resolve to an address, create a</span><span class="s33"> </span><span class="s26">HostName </span><span class="s7">and use</span><span class="s33"> </span><span class="s26">HostName.toResolvedAddress()</span><span class="s7">. If you wish to obtain a string representation to be part of a URL, use</span><span class="s33"> </span><span class="s26">HostName.toNormalizedString()</span><span class="s33">.</span></p>
<p class="p14"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #b40004; -webkit-text-stroke: #b40004"><span class="s7">Sorting and Comparisons</span></h2>
<p class="p8"><span class="s7">Comparing and sorting can be useful for storing addresses in certain types of data structures.  All of the core classes implement </span><span class="s9">java.lang.Comparable</span><span class="s7">.  Different representations of the same address or subnet are considered equal.  Different representations of the same set of addresses are considered equal.  However, </span><span class="s9">HostName</span><span class="s7"> instances, </span><span class="s9">IPAddressString</span><span class="s7"> instances, and </span><span class="s9">IPAddress</span><span class="s7"> instances are not equal even when representing the same address or subnet.</span></p>
<p class="p8"><span class="s7"> <br>
The library provides </span><span class="s9">IPAddressComparator</span><span class="s7"> and some implementations for comparison purposes.  </span><span class="s9">IPAddress</span><span class="s7"> uses the subclass </span><span class="s26">CountComparator</span><span class="s7">.  When comparing subnets, you can either emphasize the count of addresses, or you can emphasize the values of the lower or upper address represented by the subnet, and comparators are provided for those variations.</span></p>
<p class="p14"><span class="s7"> </span></p>
<h2 style="margin: 0.0px 0.0px 8.0px 0.0px; line-height: 31.0px; font: 24.0px Arial; color: #1a1a1a; -webkit-text-stroke: #1a1a1a"><span class="s7">Cache Classes</span></h2>
<p class="p8"><span class="s7">The </span><span class="s9">IPAddressNetwork</span><span class="s7"> class defines </span><span class="s9">IPAddressStringCache</span><span class="s7"> and </span><span class="s9">HostNameCache</span><span class="s7">.  These cache classes allow you to cache identifier strings (hosts and/or addresses).  Note that the identifier strings themselves will also cache their associated addresses, whether parsed or resolved.  Also note that addresses cache their associated strings and various other objects.  Therefore, these cache classes go a long way towards allowing you to avoid creating the same objects frequently.  These caches do quick lookups using either bytes or strings, which can be ideal for some applications that handle many addresses or host names.</span></p>
<p class="p14"><span class="s7"> </span></p>
<p class="p48"><span class="s7"></span><br></p>
</body>
</html>
